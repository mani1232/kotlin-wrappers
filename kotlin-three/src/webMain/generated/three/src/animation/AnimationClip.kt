// Generated by Karakum - do not modify it manually!

@file:JsModule("three")

package three.src.animation

import js.objects.Record
import three.src.AnimationBlendMode
import three.src.core.Object3D
import three.src.math.Vector3
import three.src.objects.Bone
import kotlin.js.JsAny
import kotlin.js.JsModule
import kotlin.js.JsString
import kotlin.js.definedExternally

// unhandled import: AnimationBlendMode from "../constants.js"
// unhandled import: Object3D from "../core/Object3D.js"
// unhandled import: Vector3 from "../math/Vector3.js"
// unhandled import: Bone from "../objects/Bone.js"
// unhandled import: KeyframeTrack from "./KeyframeTrack.js"
// unhandled import: KeyframeTrackJSON from "./KeyframeTrack.js"











external interface AnimationClipJSON: JsAny {
var name: String
var duration: Double
var tracks: js.array.ReadonlyArray<KeyframeTrackJSON>
var uuid: String
var blendMode: AnimationBlendMode
}

external interface MorphTarget {
var name: String
var vertices: js.array.ReadonlyArray<Vector3>
}

/**
 * A reusable set of keyframe tracks which represent an animation.
 */
external class AnimationClip {
/**
     * Constructs a new animation clip.
     *
     * Note: Instead of instantiating an AnimationClip directly with the constructor, you can
     * use the static interface of this class for creating clips. In most cases though, animation clips
     * will automatically be created by loaders when importing animated 3D assets.
     *
     * @param {string} [name=''] - The clip's name.
     * @param {number} [duration=-1] - The clip's duration in seconds. If a negative value is passed,
     * the duration will be calculated from the passed keyframes.
     * @param {Array<KeyframeTrack>} tracks - An array of keyframe tracks.
     * @param {(NormalAnimationBlendMode|AdditiveAnimationBlendMode)} [blendMode=NormalAnimationBlendMode] - Defines how the animation
     * is blended/combined when two or more animations are simultaneously played.
     */
constructor (name: String = definedExternally, duration: Double = definedExternally, tracks: Array<KeyframeTrack> = definedExternally, blendMode: AnimationBlendMode = definedExternally)
/**
     * The clip's name.
     */
var name: String
/**
     *  An array of keyframe tracks.
     */
var tracks: Array<KeyframeTrack>
/**
     * The clip's duration in seconds.
     */
var duration: Double
/**
     * Defines how the animation is blended/combined when two or more animations
     * are simultaneously played.
     */
var blendMode: AnimationBlendMode
/**
     * The UUID of the animation clip.
     */
val uuid: String
/**
     * An object that can be used to store custom data about the animation clip.
     * It should not hold references to functions as these will not be cloned.
     */
var userData: Record<JsString, JsAny?>
/**
     * Sets the duration of this clip to the duration of its longest keyframe track.
     *
     * @return {AnimationClip} A reference to this animation clip.
     */
fun resetDuration(): AnimationClip
/**
     * Trims all tracks to the clip's duration.
     *
     * @return {AnimationClip} A reference to this animation clip.
     */
fun trim(): AnimationClip
/**
     * Performs minimal validation on each track in the clip. Returns `true` if all
     * tracks are valid.
     *
     * @return {boolean} Whether the clip's keyframes are valid or not.
     */
fun validate(): Boolean
/**
     * Optimizes each track by removing equivalent sequential keys (which are
     * common in morph target sequences).
     *
     * @return {AnimationClip} A reference to this animation clip.
     */
fun optimize(): AnimationClip
/**
     * Returns a new animation clip with copied values from this instance.
     *
     * @return {AnimationClip} A clone of this instance.
     */
fun clone(): Unit /* this */
/**
     * Serializes this animation clip into JSON.
     *
     * @return {Object} The JSON object.
     */
fun toJSON(): AnimationClipJSON
companion object {
/**
     * Factory method for creating an animation clip from the given JSON.
     *
     * @static
     * @param {Object} json - The serialized animation clip.
     * @return {AnimationClip} The new animation clip.
     */
fun parse(json: AnimationClipJSON): AnimationClip
/**
     * Serializes the given animation clip into JSON.
     *
     * @static
     * @param {AnimationClip} clip - The animation clip to serialize.
     * @return {Object} The JSON object.
     */
fun toJSON(clip: AnimationClip): AnimationClipJSON
/**
     * Returns a new animation clip from the passed morph targets array of a
     * geometry, taking a name and the number of frames per second.
     *
     * Note: The fps parameter is required, but the animation speed can be
     * overridden via {@link AnimationAction#setDuration}.
     *
     * @static
     * @param {string} name - The name of the animation clip.
     * @param {Array<Object>} morphTargetSequence - A sequence of morph targets.
     * @param {number} fps - The Frames-Per-Second value.
     * @param {boolean} noLoop - Whether the clip should be no loop or not.
     * @return {AnimationClip} The new animation clip.
     */
fun CreateFromMorphTargetSequence(name: String, morphTargetSequence: Array<MorphTarget>, fps: Double, noLoop: Boolean): AnimationClip
/**
     * Searches for an animation clip by name, taking as its first parameter
     * either an array of clips, or a mesh or geometry that contains an
     * array named "animations" property.
     *
     * @static
     * @param {(Array<AnimationClip>|Object3D)} objectOrClipArray - The array or object to search through.
     * @param {string} name - The name to search for.
     * @return {?AnimationClip} The found animation clip. Returns `null` if no clip has been found.
     */
fun findByName(objectOrClipArray: Array<AnimationClip>, name: String): AnimationClip?

/**
     * Searches for an animation clip by name, taking as its first parameter
     * either an array of clips, or a mesh or geometry that contains an
     * array named "animations" property.
     *
     * @static
     * @param {(Array<AnimationClip>|Object3D)} objectOrClipArray - The array or object to search through.
     * @param {string} name - The name to search for.
     * @return {?AnimationClip} The found animation clip. Returns `null` if no clip has been found.
     */
fun findByName(objectOrClipArray: Object3D, name: String): AnimationClip?
/**
     * Returns an array of new AnimationClips created from the morph target
     * sequences of a geometry, trying to sort morph target names into
     * animation-group-based patterns like "Walk_001, Walk_002, Run_001, Run_002...".
     *
     * See {@link MD2Loader#parse} as an example for how the method should be used.
     *
     * @static
     * @param {Array<Object>} morphTargets - A sequence of morph targets.
     * @param {number} fps - The Frames-Per-Second value.
     * @param {boolean} noLoop - Whether the clip should be no loop or not.
     * @return {Array<AnimationClip>} An array of new animation clips.
     */
fun CreateClipsFromMorphTargetSequences(morphTargets: Array<MorphTarget>, fps: Double, noLoop: Boolean): Array<AnimationClip>
/**
     * Parses the `animation.hierarchy` format and returns a new animation clip.
     *
     * @static
     * @deprecated since r175.
     * @param {Object} animation - A serialized animation clip as JSON.
     * @param {Array<Bones>} bones - An array of bones.
     * @return {?AnimationClip} The new animation clip.
     */
fun parseAnimation(animation: AnimationClipJSON, bones: Array<Bone>): AnimationClip?
}
}
