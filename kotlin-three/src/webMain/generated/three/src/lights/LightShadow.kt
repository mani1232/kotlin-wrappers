// Generated by Karakum - do not modify it manually!

@file:JsModule("three")

package three.src.lights

import three.src.cameras.Camera
import three.src.core.Object3DJSONObject
import three.src.math.Vector2Tuple
import kotlin.js.JsAny
import kotlin.js.JsModule

// unhandled import: Camera from "../cameras/Camera.js"
// unhandled import: TextureDataType from "../constants.js"
// unhandled import: Object3DJSONObject from "../core/Object3D.js"
// unhandled import: Frustum from "../math/Frustum.js"
// unhandled import: Matrix4 from "../math/Matrix4.js"
// unhandled import: Vector2 from "../math/Vector2.js"
// unhandled import: Vector2Tuple from "../math/Vector2.js"
// unhandled import: Vector4 from "../math/Vector4.js"
// unhandled import: WebGLRenderTarget from "../renderers/WebGLRenderTarget.js"
// unhandled import: Light from "./Light.js"



















external interface LightShadowJSON {
var intensity: Double?
var bias: Double?
var normalBias: Double?
var radius: Double?
var mapSize: Vector2Tuple?
var camera: Omit<Object3DJSONObject, String /* "matrix" */>
}

/**
 * Serves as a base class for the other shadow classes.
 * @see {@link https://threejs.org/docs/index.html#api/en/lights/shadows/LightShadow | Official Documentation}
 * @see {@link https://github.com/mrdoob/three.js/blob/master/src/lights/LightShadow.js | Source}
 */
external class LightShadow<TCamera : Camera /* default is Camera */>: JsAny {
/**
     * Create a new instance of {@link LightShadow}
     * @param camera The light's view of the world.
     */
constructor (camera: TCamera)
/**
     * The light's view of the world.
     * @remark This is used to generate a depth map of the scene; objects behind other objects from the light's perspective will be in shadow.
     */
var camera: TCamera
/**
     * The intensity of the shadow. The default is `1`. Valid values are in the range `[0, 1]`.
     */
var intensity: Double
/**
     * Shadow map bias, how much to add or subtract from the normalized depth when deciding whether a surface is in shadow.
     * @remark The Very tiny adjustments here (in the order of 0.0001) may help reduce artifacts in shadows.
     * @remarks Expects a `Float`
     * @defaultValue `0`
     */
var bias: Double
/**
     * Defines how much the position used to query the shadow map is offset along the object normal.
     * @remark The Increasing this value can be used to reduce shadow acne especially in large scenes where light shines onto geometry at a shallow angle.
     * @remark The cost is that shadows may appear distorted.
     * @remarks Expects a `Float`
     * @defaultValue `0`
     */
var normalBias: Double
/**
     * Setting this to values greater than 1 will blur the edges of the shadow.toi
     * @remark High values will cause unwanted banding effects in the shadows - a greater {@link LightShadow.mapSize | mapSize
     *  will allow for a higher value to be used here before these effects become visible.
     * @remark If {@link THREE.WebGLRenderer.shadowMap.type | WebGLRenderer.shadowMap.type} is set to {@link Renderer | PCFSoftShadowMap},
     * radius has no effect and it is recommended to increase softness by decreasing {@link LightShadow.mapSize | mapSize} instead.
     * @remark Note that this has no effect if the {@link THREE.WebGLRenderer.shadowMap | WebGLRenderer.shadowMap}.{@link THREE.WebGLShadowMap.type | type}
     * is set to {@link THREE.BasicShadowMap | BasicShadowMap}.
     * @remarks Expects a `Float`
     * @defaultValue `1`
     */
var radius: Double
/**
     * The amount of samples to use when blurring a VSM shadow map.
     * @remarks Expects a `Integer`
     * @defaultValue `8`
     */
var blurSamples: Double
/**
     * A {@link THREE.Vector2 | Vector2} defining the width and height of the shadow map.
     * @remarks Higher values give better quality shadows at the cost of computation time.
     * @remarks Values must be powers of 2, up to the {@link THREE.WebGLRenderer.capabilities | WebGLRenderer.capabilities}.maxTextureSize for a given device,
     * although the width and height don't have to be the same (so, for example, (512, 1024) is valid).
     * @defaultValue `new THREE.Vector2(512, 512)`
     */
var mapSize: Vector2
/**
     * The type of shadow texture. The default is `UnsignedByteType`.
     *
     * @default UnsignedByteType
     */
var mapType: TextureDataType
/**
     * The depth map generated using the internal camera; a location beyond a pixel's depth is in shadow. Computed internally during rendering.
     * @defaultValue null
     */
var map: WebGLRenderTarget?
/**
     * The distribution map generated using the internal camera; an occlusion is calculated based on the distribution of depths. Computed internally during rendering.
     * @defaultValue null
     */
var mapPass: WebGLRenderTarget?
/**
     * Model to shadow camera space, to compute location and depth in shadow map.
     * Stored in a {@link Matrix4 | Matrix4}.
     * @remarks This is computed internally during rendering.
     * @defaultValue new THREE.Matrix4()
     */
var matrix: Matrix4
/**
     * Enables automatic updates of the light's shadow. If you do not require dynamic lighting / shadows, you may set this to `false`.
     * @defaultValue `true`
     */
var autoUpdate: Boolean
/**
     * When set to `true`, shadow maps will be updated in the next `render` call.
     * If you have set {@link autoUpdate} to `false`, you will need to set this property to `true` and then make a render call to update the light's shadow.
     * @defaultValue `false`
     */
var needsUpdate: Boolean
/**
     * Used internally by the renderer to get the number of viewports that need to be rendered for this shadow.
     */
fun getViewportCount(): Double
/**
     * Copies value of all the properties from the {@link {@link LightShadow} | source} to this Light.
     * @param source
     */
fun copy(source: LightShadow): Unit /* this */
/**
     * Creates a new {@link LightShadow} with the same properties as this one.
     */
fun clone(recursive: Boolean = definedExternally): Unit /* this */
/**
     * Serialize this LightShadow.
     */
fun toJSON(): LightShadowJSON
/**
     * Gets the shadow cameras frustum
     * @remarks
     * Used internally by the renderer to cull objects.
     */
fun getFrustum(): Frustum
/**
     * Update the matrices for the camera and shadow, used internally by the renderer.
     * @param light The light for which the shadow is being rendered.
     */
fun updateMatrices(light: Light): Unit
fun getViewport(viewportIndex: Double): Vector4
/**
     * Used internally by the renderer to extend the shadow map to contain all viewports
     */
fun getFrameExtents(): Vector2
/**
     * Frees the GPU-related resources allocated by this instance
     * @remarks
     * Call this method whenever this instance is no longer used in your app.
     */
fun dispose(): Unit
var shadowNode: Node?
}
