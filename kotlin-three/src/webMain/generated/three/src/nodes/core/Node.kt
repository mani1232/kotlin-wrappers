// Generated by Karakum - do not modify it manually!

@file:JsModule("three")

package three.src.nodes.core

import js.core.Void
import js.generator.Generator
import three.src.core.EventDispatcher
import three.src.nodes.tsl.Swizzable
import kotlin.js.JsAny
import kotlin.js.definedExternally
import kotlin.js.JsModule

// unhandled import: EventDispatcher from "../../core/EventDispatcher.js"
// unhandled import: NodeUpdateType from "./constants.js"
// unhandled import: default as NodeBuilder from "./NodeBuilder.js"
// unhandled import: default as NodeFrame from "./NodeFrame.js"









external interface NodeJSONMeta {
var textures: NodeJSONMetaTextures
var images: NodeJSONMetaImages
var nodes: NodeJSONMetaNodes
}

external interface NodeJSONMetadata {
var version: Double
var type: String /* "Node" */
var generator: String /* "Node.toJSON" */
}

external interface NodeJSONInputNodes {
operator fun get(key: String): Any? /* string[] | {
    [index: string]: string | undefined;
} | string | undefined */

operator fun set(key: String, value: Any? /* string[] | {
    [index: string]: string | undefined;
} | string | undefined */)
}

external interface NodeJSONInputData {
var inputNodes: NodeJSONInputNodes?
var meta: NodeJSONInputDataMeta
}

external interface NodeJSONIntermediateOutputData {
var uuid: String
var type: String?
var meta: NodeJSONMeta?
var metadata: NodeJSONMetadata?
var inputNodes: NodeJSONInputNodes?
var textures: js.array.ReadonlyArray<Any?>?
var images: js.array.ReadonlyArray<Any?>?
var nodes: js.array.ReadonlyArray<NodeJSONIntermediateOutputData>?
}

external interface NodeJSONOutputData {
var uuid: String
var type: String?
var metadata: NodeJSONMetadata?
var inputNodes: NodeJSONInputNodes?
var textures: js.array.ReadonlyArray<Any?>?
var images: js.array.ReadonlyArray<Any?>?
var nodes: js.array.ReadonlyArray<NodeJSONOutputData>?
}

external interface NodeChild {
var property: String
var index: (Any /* number | string */)?
var childNode: Node
}

/**
 * Base class for all nodes.
 *
 * @augments EventDispatcher
 */
open external class Node : EventDispatcher<Temp112>, Swizzable, JsAny {
/**
     * Constructs a new node.
     *
     * @param {?string} nodeType - The node type.
     */
constructor (nodeType: String? = definedExternally)
var nodeType: String?
var updateType: NodeUpdateType
var updateBeforeType: NodeUpdateType
var updateAfterType: NodeUpdateType
var uuid: String
var version: Double
var name: String?
var _cacheKey: Double?
var _cacheKeyVersion: Double
var global: Boolean
var parents: Boolean
val isNode: Boolean /* true */
val id: Double
var self: Unit /* this */?
/**
     * Set this property to `true` when the node should be regenerated.
     *
     * @type {boolean}
     * @default false
     * @param {boolean} value
     */
var needsUpdate: Boolean
/**
     * The type of the class. The value is usually the constructor name.
     *
     * @type {string}
     * @readonly
     */
val type: String?
/**
     * Convenient method for defining {@link Node#update}.
     *
     * @param {Function} callback - The update method.
     * @param {string} updateType - The update type.
     * @return {Node} A reference to this node.
     */
fun onUpdate(callback: (/* this: this, */ frame: NodeFrame) -> Any?, updateType: NodeUpdateType): Unit /* this */
/**
     * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
     * this method automatically sets the update type to `FRAME`.
     *
     * @param {Function} callback - The update method.
     * @return {Node} A reference to this node.
     */
fun onFrameUpdate(callback: (/* this: this, */ frame: NodeFrame) -> Unit): Unit /* this */
/**
     * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
     * this method automatically sets the update type to `RENDER`.
     *
     * @param {Function} callback - The update method.
     * @return {Node} A reference to this node.
     */
fun onRenderUpdate(callback: (/* this: this, */ frame: NodeFrame) -> Unit): Unit /* this */
/**
     * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
     * this method automatically sets the update type to `OBJECT`.
     *
     * @param {Function} callback - The update method.
     * @return {Node} A reference to this node.
     */
fun onObjectUpdate(callback: (/* this: this, */ frame: NodeFrame) -> Unit): Unit /* this */
/**
     * Convenient method for defining {@link Node#updateReference}.
     *
     * @param {Function} callback - The update method.
     * @return {Node} A reference to this node.
     */
fun onReference(callback: (/* this: this, */ frame: Any /* NodeBuilder | NodeFrame */) -> Any?): Unit /* this */
/**
     * Nodes might refer to other objects like materials. This method allows to dynamically update the reference
     * to such objects based on a given state (e.g. the current node frame or builder).
     *
     * @param {any} state - This method can be invocated in different contexts so `state` can refer to any object type.
     * @return {any} The updated reference.
     */
fun updateReference(state: NodeBuilder): Any?

/**
     * Nodes might refer to other objects like materials. This method allows to dynamically update the reference
     * to such objects based on a given state (e.g. the current node frame or builder).
     *
     * @param {any} state - This method can be invocated in different contexts so `state` can refer to any object type.
     * @return {any} The updated reference.
     */
fun updateReference(state: NodeFrame): Any?
/**
     * By default this method returns the value of the {@link Node#global} flag. This method
     * can be overwritten in derived classes if an analytical way is required to determine the
     * global cache referring to the current shader-stage.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {boolean} Whether this node is global or not.
     */
fun isGlobal(builder: NodeBuilder): Boolean
/**
     * Generator function that can be used to iterate over the child nodes.
     *
     * @generator
     * @yields {Node} A child node.
     */
fun getChildren(): Generator<Node, Void, Any?>
/**
     * Calling this method dispatches the `dispose` event. This event can be used
     * to register event listeners for clean up tasks.
     */
fun dispose(): Unit
/**
     * Callback for {@link Node#traverse}.
     *
     * @callback traverseCallback
     * @param {Node} node - The current node.
     */
/**
     * Can be used to traverse through the node's hierarchy.
     *
     * @param {traverseCallback} callback - A callback that is executed per node.
     */
fun traverse(callback: (node: Node) -> Unit): Unit
/**
     * Returns the child nodes of this node.
     *
     * @private
     * @param {Set<Node>} [ignores=new Set()] - A set of nodes to ignore during the search to avoid circular references.
     * @returns {Array<Object>} An array of objects describing the child nodes.
     */
fun _getChildren(ignores: Set<Node> = definedExternally): js.array.ReadonlyArray<NodeChild>
/**
     * Returns the cache key for this node.
     *
     * @param {boolean} [force=false] - When set to `true`, a recomputation of the cache key is forced.
     * @param {Set<Node>} [ignores=null] - A set of nodes to ignore during the computation of the cache key.
     * @return {number} The cache key of the node.
     */
fun getCacheKey(force: Boolean = definedExternally, ignores: Set<Node>? = definedExternally): Double
/**
     * Generate a custom cache key for this node.
     *
     * @return {number} The cache key of the node.
     */
fun customCacheKey(): Double
/**
     * Returns the references to this node which is by default `this`.
     *
     * @return {Node} A reference to this node.
     */
fun getScope(): Unit /* this */
/**
     * Returns the hash of the node which is used to identify the node. By default it's
     * the {@link Node#uuid} however derived node classes might have to overwrite this method
     * depending on their implementation.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {string} The hash.
     */
fun getHash(builder: NodeBuilder): String
/**
     * Returns the update type of {@link Node#update}.
     *
     * @return {NodeUpdateType} The update type.
     */
fun getUpdateType(): NodeUpdateType
/**
     * Returns the update type of {@link Node#updateBefore}.
     *
     * @return {NodeUpdateType} The update type.
     */
fun getUpdateBeforeType(): NodeUpdateType
/**
     * Returns the update type of {@link Node#updateAfter}.
     *
     * @return {NodeUpdateType} The update type.
     */
fun getUpdateAfterType(): NodeUpdateType
/**
     * Certain types are composed of multiple elements. For example a `vec3`
     * is composed of three `float` values. This method returns the type of
     * these elements.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {string} The type of the node.
     */
fun getElementType(builder: NodeBuilder): NodeGetElementTypeResult?
/**
     * Returns the node member type for the given name.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @param {string} name - The name of the member.
     * @return {string} The type of the node.
     */
fun getMemberType(builder: NodeBuilder, name: String): String
/**
     * Returns the node's type.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {string} The type of the node.
     */
fun getNodeType(builder: NodeBuilder): String?
/**
     * This method is used during the build process of a node and ensures
     * equal nodes are not built multiple times but just once. For example if
     * `attribute( 'uv' )` is used multiple times by the user, the build
     * process makes sure to process just the first node.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {Node} The shared node if possible. Otherwise `this` is returned.
     */
fun getShared(builder: NodeBuilder): Node
/**
     * Returns the number of elements in the node array.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {?number} The number of elements in the node array.
     */
fun getArrayCount(builder: NodeBuilder): Double?
/**
     * Represents the setup stage which is the first step of the build process, see {@link Node#build} method.
     * This method is often overwritten in derived modules to prepare the node which is used as a node's output/result.
     * If an output node is prepared, then it must be returned in the `return` statement of the derived module's setup function.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {?Node} The output node.
     */
fun setup(builder: NodeBuilder): Any?
/**
     * Represents the analyze stage which is the second step of the build process, see {@link Node#build} method.
     * This stage analyzes the node hierarchy and ensures descendent nodes are built.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @param {?Node} output - The target output node.
     */
fun analyze(builder: NodeBuilder, output: Node? = definedExternally): Unit
/**
     * Represents the generate stage which is the third step of the build process, see {@link Node#build} method.
     * This state builds the output node and returns the resulting shader string.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @param {?string} [output] - Can be used to define the output type.
     * @return {?string} The generated shader string.
     */
fun generate(builder: NodeBuilder, output: String? = definedExternally): String?
/**
     * The method can be implemented to update the node's internal state before it is used to render an object.
     * The {@link Node#updateBeforeType} property defines how often the update is executed.
     *
     * @abstract
     * @param {NodeFrame} frame - A reference to the current node frame.
     * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
     */
fun updateBefore(frame: NodeFrame): Unit
/**
     * The method can be implemented to update the node's internal state after it was used to render an object.
     * The {@link Node#updateAfterType} property defines how often the update is executed.
     *
     * @abstract
     * @param {NodeFrame} frame - A reference to the current node frame.
     * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
     */
fun updateAfter(frame: NodeFrame): Unit
/**
     * The method can be implemented to update the node's internal state when it is used to render an object.
     * The {@link Node#updateType} property defines how often the update is executed.
     *
     * @abstract
     * @param {NodeFrame} frame - A reference to the current node frame.
     * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
     */
fun update(frame: NodeFrame): Unit
fun before(node: Node): Unit /* this */
/**
     * This method performs the build of a node. The behavior and return value depend on the current build stage:
     * - **setup**: Prepares the node and its children for the build process. This process can also create new nodes. Returns the node itself or a variant.
     * - **analyze**: Analyzes the node hierarchy for optimizations in the code generation stage. Returns `null`.
     * - **generate**: Generates the shader code for the node. Returns the generated shader string.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @param {?(string|Node)} [output=null] - Can be used to define the output type.
     * @return {?(Node|string)} The result of the build process, depending on the build stage.
     */
fun build(builder: NodeBuilder): Any? /* Node | string | null */

/**
     * This method performs the build of a node. The behavior and return value depend on the current build stage:
     * - **setup**: Prepares the node and its children for the build process. This process can also create new nodes. Returns the node itself or a variant.
     * - **analyze**: Analyzes the node hierarchy for optimizations in the code generation stage. Returns `null`.
     * - **generate**: Generates the shader code for the node. Returns the generated shader string.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @param {?(string|Node)} [output=null] - Can be used to define the output type.
     * @return {?(Node|string)} The result of the build process, depending on the build stage.
     */
fun build(builder: NodeBuilder, output: String? = definedExternally): Any? /* Node | string | null */

/**
     * This method performs the build of a node. The behavior and return value depend on the current build stage:
     * - **setup**: Prepares the node and its children for the build process. This process can also create new nodes. Returns the node itself or a variant.
     * - **analyze**: Analyzes the node hierarchy for optimizations in the code generation stage. Returns `null`.
     * - **generate**: Generates the shader code for the node. Returns the generated shader string.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @param {?(string|Node)} [output=null] - Can be used to define the output type.
     * @return {?(Node|string)} The result of the build process, depending on the build stage.
     */
fun build(builder: NodeBuilder, output: Node? = definedExternally): Any? /* Node | string | null */
/**
     * Returns the child nodes as a JSON object.
     *
     * @return {Generator<Object>} An iterable list of serialized child objects as JSON.
     */
fun getSerializeChildren(): js.array.ReadonlyArray<NodeChild>
/**
     * Serializes the node to JSON.
     *
     * @param {Object} json - The output JSON object.
     */
fun serialize(json: NodeJSONIntermediateOutputData): Unit
/**
     * Deserializes the node from the given JSON.
     *
     * @param {Object} json - The JSON object.
     */
fun deserialize(json: NodeJSONInputData): Unit
/**
     * Serializes the node into the three.js JSON Object/Scene format.
     *
     * @param {?Object} meta - An optional JSON object that already holds serialized data from other scene objects.
     * @return {Object} The serialized node.
     */
fun toJSON(): NodeJSONOutputData

/**
     * Serializes the node into the three.js JSON Object/Scene format.
     *
     * @param {?Object} meta - An optional JSON object that already holds serialized data from other scene objects.
     * @return {Object} The serialized node.
     */
fun toJSON(meta: NodeJSONMeta = definedExternally): NodeJSONOutputData

/**
     * Serializes the node into the three.js JSON Object/Scene format.
     *
     * @param {?Object} meta - An optional JSON object that already holds serialized data from other scene objects.
     * @return {Object} The serialized node.
     */
fun toJSON(meta: String = definedExternally): NodeJSONOutputData
var toArray: (count: Double) -> ArrayNode
var toArrayAssign: (count: Double) -> Unit /* this */
var bypass: (callNode: Node) -> BypassNode
var bypassAssign: (callNode: Node) -> Unit /* this */
var context: (context: NodeBuilderContext? /* use undefined for default */) -> ContextNode
var contextAssign: (context: NodeBuilderContext? /* use undefined for default */) -> Unit /* this */
/**
         * @deprecated "label()" has been deprecated. Use "setName()" instead.
         */
var label: (label: String) -> Node
/**
         * @deprecated "label()" has been deprecated. Use "setName()" instead.
         */
var labelAssign: (label: String) -> Unit /* this */
var uniformFlow: () -> ContextNode
var uniformFlowAssign: () -> Unit /* this */
var setName: (label: String) -> Node
var setNameAssign: (label: String) -> Unit /* this */
var builtinShadowContext: (shadowNode: Node, light: Light) -> ContextNode
var builtinShadowContextAssign: (shadowNode: Node, light: Light) -> Unit /* this */
var builtinAOContext: (aoValue: Node) -> ContextNode
var builtinAOContextAssign: (aoValue: Node) -> Unit /* this */
/**
         * @deprecated "cache()" has been deprecated. Use "isolate()" instead.
         */
var cache: (cache: NodeCache? /* use undefined for default */) -> IsolateNode
/**
         * @deprecated "cache()" has been deprecated. Use "isolate()" instead.
         */
var cacheAssign: (cache: NodeCache? /* use undefined for default */) -> Unit /* this */
var isolate: () -> IsolateNode
var isolateAssign: () -> Unit /* this */
var toVar: (name: String? /* use undefined for default */) -> VarNode
var toVarAssign: (name: String? /* use undefined for default */) -> Unit /* this */
var toConst: (name: String? /* use undefined for default */) -> VarNode
var toConstAssign: (name: String? /* use undefined for default */) -> Unit /* this */
var toVarIntent: () -> Node
var toVarIntentAssign: () -> Unit /* this */
var toVarying: (name: String? /* use undefined for default */) -> VaryingNode
var toVaryingAssign: (name: String? /* use undefined for default */) -> Unit /* this */
var toVertexStage: () -> VaryingNode
var toVertexStageAssign: () -> Unit /* this */
/**
         * @deprecated .vertexStage() has been renamed to .toVertexStage().
         */
var vertexStage: () -> VaryingNode
/**
         * @deprecated .vertexStage() has been renamed to .toVertexStage().
         */
var vertexStageAssign: () -> Unit /* this */
var debug: (callback: ((node: NodeBuilder, code: String) -> Unit)? /* use undefined for default */) -> DebugNode
var debugAssign: (callback: ((node: NodeBuilder, code: String) -> Unit)? /* use undefined for default */) -> Unit /* this */
var remap: (inLowNode: Any /* Node | number */, inHighNode: Any /* Node | number */, outLowNode: (Any /* Node | number */)? /* use undefined for default */, outHighNode: (Any /* Node | number */)? /* use undefined for default */) -> RemapNode
var remapAssign: (inLowNode: Any /* Node | number */, inHighNode: Any /* Node | number */, outLowNode: (Any /* Node | number */)? /* use undefined for default */, outHighNode: (Any /* Node | number */)? /* use undefined for default */) -> Unit /* this */
var remapClamp: (inLowNode: Any /* Node | number */, inHighNode: Any /* Node | number */, outLowNode: (Any /* Node | number */)? /* use undefined for default */, outHighNode: (Any /* Node | number */)? /* use undefined for default */) -> RemapNode
var remapClampAssign: (inLowNode: Any /* Node | number */, inHighNode: Any /* Node | number */, outLowNode: (Any /* Node | number */)? /* use undefined for default */, outHighNode: (Any /* Node | number */)? /* use undefined for default */) -> Unit /* this */
var assign: (sourceNode: Any /* Node | number */) -> Unit /* this */
var get: (value: String) -> Node
var toStack: () -> Node
var toStackAssign: () -> Unit /* this */
var toColor: () -> Node
var toColorAssign: () -> Unit /* this */
var toFloat: () -> Node
var toFloatAssign: () -> Unit /* this */
var toInt: () -> Node
var toIntAssign: () -> Unit /* this */
var toUint: () -> Node
var toUintAssign: () -> Unit /* this */
var toBool: () -> Node
var toBoolAssign: () -> Unit /* this */
var toVec2: () -> Node
var toVec2Assign: () -> Unit /* this */
var toIVec2: () -> Node
var toIVec2Assign: () -> Unit /* this */
var toUVec2: () -> Node
var toUVec2Assign: () -> Unit /* this */
var toBVec2: () -> Node
var toBVec2Assign: () -> Unit /* this */
var toVec3: () -> Node
var toVec3Assign: () -> Unit /* this */
var toIVec3: () -> Node
var toIVec3Assign: () -> Unit /* this */
var toUVec3: () -> Node
var toUVec3Assign: () -> Unit /* this */
var toBVec3: () -> Node
var toBVec3Assign: () -> Unit /* this */
var toVec4: () -> Node
var toVec4Assign: () -> Unit /* this */
var toIVec4: () -> Node
var toIVec4Assign: () -> Unit /* this */
var toUVec4: () -> Node
var toUVec4Assign: () -> Unit /* this */
var toBVec4: () -> Node
var toBVec4Assign: () -> Unit /* this */
var toMat2: () -> Node
var toMat2Assign: () -> Unit /* this */
var toMat3: () -> Node
var toMat3Assign: () -> Unit /* this */
var toMat4: () -> Node
var toMat4Assign: () -> Unit /* this */
var element: (indexNode: Node) -> Node
var elementAssign: (indexNode: Node) -> Unit /* this */
var convert: (types: String) -> Node
var convertAssign: (types: String) -> Unit /* this */
/**
         * @deprecated append() has been renamed to Stack().
         */
var append: () -> Node
/**
         * @deprecated append() has been renamed to Stack().
         */
var appendAssign: () -> Unit /* this */
var workingToColorSpace: (targetColorSpace: String) -> ColorSpaceNode
var workingToColorSpaceAssign: (targetColorSpace: String) -> Unit /* this */
var colorSpaceToWorking: (sourceColorSpace: String) -> ColorSpaceNode
var colorSpaceToWorkingAssign: (sourceColorSpace: String) -> Unit /* this */
var renderOutput: (toneMapping: ToneMapping? /* use undefined for default */, outputColorSpace: String? /* use undefined for default */) -> RenderOutputNode
var renderOutputAssign: (toneMapping: ToneMapping? /* use undefined for default */, outputColorSpace: String? /* use undefined for default */) -> Unit /* this */
var toneMapping: (mapping: ToneMapping? /* use undefined for default */, exposure: (Any /* Node | number */)? /* use undefined for default */) -> ToneMappingNode
var toneMappingAssign: (mapping: ToneMapping? /* use undefined for default */, exposure: (Any /* Node | number */)? /* use undefined for default */) -> Unit /* this */
var compute: (count: Double, workgroupSize: js.array.ReadonlyArray<Double>? /* use undefined for default */) -> ComputeNode
var computeAssign: (count: Double, workgroupSize: js.array.ReadonlyArray<Double>? /* use undefined for default */) -> Unit /* this */
var computeKernel: (workgroupSize: js.array.ReadonlyArray<Double>? /* use undefined for default */) -> ComputeNode
var computeKernelAssign: (workgroupSize: js.array.ReadonlyArray<Double>? /* use undefined for default */) -> Unit /* this */
var add: Function<OperatorNode> /* (b: OperatorNodeParameter, ...params: OperatorNodeParameter[]) => OperatorNode */
var addAssign: Function<Unit /* this */> /* (b: OperatorNodeParameter, ...params: OperatorNodeParameter[]) => this */
var sub: Function<OperatorNode> /* (b: OperatorNodeParameter, ...params: OperatorNodeParameter[]) => OperatorNode */
var subAssign: Function<Unit /* this */> /* (b: OperatorNodeParameter, ...params: OperatorNodeParameter[]) => this */
var mul: Function<OperatorNode> /* (b: OperatorNodeParameter, ...params: OperatorNodeParameter[]) => OperatorNode */
var mulAssign: Function<Unit /* this */> /* (b: OperatorNodeParameter, ...params: OperatorNodeParameter[]) => this */
var div: Function<OperatorNode> /* (b: OperatorNodeParameter, ...params: OperatorNodeParameter[]) => OperatorNode */
var divAssign: Function<Unit /* this */> /* (b: OperatorNodeParameter, ...params: OperatorNodeParameter[]) => this */
var mod: (b: OperatorNodeParameter) -> OperatorNode
var modAssign: (b: OperatorNodeParameter) -> Unit /* this */
var equal: (b: OperatorNodeParameter) -> OperatorNode
var equalAssign: (b: OperatorNodeParameter) -> Unit /* this */
var notEqual: (b: OperatorNodeParameter) -> OperatorNode
var notEqualAssign: (b: OperatorNodeParameter) -> Unit /* this */
var lessThan: (b: OperatorNodeParameter) -> OperatorNode
var lessThanAssign: (b: OperatorNodeParameter) -> Unit /* this */
var greaterThan: (b: OperatorNodeParameter) -> OperatorNode
var greaterThanAssign: (b: OperatorNodeParameter) -> Unit /* this */
var lessThanEqual: (b: OperatorNodeParameter) -> OperatorNode
var lessThanEqualAssign: (b: OperatorNodeParameter) -> Unit /* this */
var greaterThanEqual: (b: OperatorNodeParameter) -> OperatorNode
var greaterThanEqualAssign: (b: OperatorNodeParameter) -> Unit /* this */
var and: Function<OperatorNode> /* (b: OperatorNodeParameter, ...params: OperatorNodeParameter[]) => OperatorNode */
var andAssign: Function<Unit /* this */> /* (b: OperatorNodeParameter, ...params: OperatorNodeParameter[]) => this */
var or: Function<OperatorNode> /* (b: OperatorNodeParameter, ...params: OperatorNodeParameter[]) => OperatorNode */
var orAssign: Function<Unit /* this */> /* (b: OperatorNodeParameter, ...params: OperatorNodeParameter[]) => this */
var not: () -> OperatorNode
var notAssign: () -> Unit /* this */
var xor: (b: OperatorNodeParameter) -> OperatorNode
var xorAssign: (b: OperatorNodeParameter) -> Unit /* this */
var bitAnd: (b: OperatorNodeParameter) -> OperatorNode
var bitAndAssign: (b: OperatorNodeParameter) -> Unit /* this */
var bitNot: (b: OperatorNodeParameter) -> OperatorNode
var bitNotAssign: (b: OperatorNodeParameter) -> Unit /* this */
var bitOr: (b: OperatorNodeParameter) -> OperatorNode
var bitOrAssign: (b: OperatorNodeParameter) -> Unit /* this */
var bitXor: (b: OperatorNodeParameter) -> OperatorNode
var bitXorAssign: (b: OperatorNodeParameter) -> Unit /* this */
var shiftLeft: (b: OperatorNodeParameter) -> OperatorNode
var shiftLeftAssign: (b: OperatorNodeParameter) -> Unit /* this */
var shiftRight: (b: OperatorNodeParameter) -> OperatorNode
var shiftRightAssign: (b: OperatorNodeParameter) -> Unit /* this */
var incrementBefore: () -> OperatorNode
var incrementBeforeAssign: () -> Unit /* this */
var decrementBefore: () -> OperatorNode
var decrementBeforeAssign: () -> Unit /* this */
var increment: () -> OperatorNode
var incrementAssign: () -> Unit /* this */
var decrement: () -> OperatorNode
var decrementAssign: () -> Unit /* this */
var all: () -> MathNode
var allAssign: () -> Unit /* this */
var any: () -> MathNode
var anyAssign: () -> Unit /* this */
/**
         * @deprecated "equals" is deprecated. Use "equal" inside a vector instead, like: "bvec*( equal( ... ) )"
         */
var equals: () -> MathNode
/**
         * @deprecated "equals" is deprecated. Use "equal" inside a vector instead, like: "bvec*( equal( ... ) )"
         */
var equalsAssign: () -> Unit /* this */
var radians: () -> MathNode
var radiansAssign: () -> Unit /* this */
var degrees: () -> MathNode
var degreesAssign: () -> Unit /* this */
var exp: () -> MathNode
var expAssign: () -> Unit /* this */
var exp2: () -> MathNode
var exp2Assign: () -> Unit /* this */
var log: () -> MathNode
var logAssign: () -> Unit /* this */
var log2: () -> MathNode
var log2Assign: () -> Unit /* this */
var sqrt: () -> MathNode
var sqrtAssign: () -> Unit /* this */
var inverseSqrt: () -> MathNode
var inverseSqrtAssign: () -> Unit /* this */
var floor: () -> MathNode
var floorAssign: () -> Unit /* this */
var ceil: () -> MathNode
var ceilAssign: () -> Unit /* this */
var normalize: () -> MathNode
var normalizeAssign: () -> Unit /* this */
var fract: () -> MathNode
var fractAssign: () -> Unit /* this */
var sin: () -> MathNode
var sinAssign: () -> Unit /* this */
var cos: () -> MathNode
var cosAssign: () -> Unit /* this */
var tan: () -> MathNode
var tanAssign: () -> Unit /* this */
var asin: () -> MathNode
var asinAssign: () -> Unit /* this */
var acos: () -> MathNode
var acosAssign: () -> Unit /* this */
var atan: (b: MathNodeParameter? /* use undefined for default */) -> MathNode
var atanAssign: (b: MathNodeParameter? /* use undefined for default */) -> Unit /* this */
var abs: () -> MathNode
var absAssign: () -> Unit /* this */
var sign: () -> MathNode
var signAssign: () -> Unit /* this */
var length: () -> MathNode
var lengthAssign: () -> Unit /* this */
var lengthSq: () -> MathNode
var lengthSqAssign: () -> Unit /* this */
var negate: () -> MathNode
var negateAssign: () -> Unit /* this */
var oneMinus: () -> MathNode
var oneMinusAssign: () -> Unit /* this */
var dFdx: () -> MathNode
var dFdxAssign: () -> Unit /* this */
var dFdy: () -> MathNode
var dFdyAssign: () -> Unit /* this */
var round: () -> MathNode
var roundAssign: () -> Unit /* this */
var reciprocal: () -> MathNode
var reciprocalAssign: () -> Unit /* this */
var trunc: () -> MathNode
var truncAssign: () -> Unit /* this */
var fwidth: () -> MathNode
var fwidthAssign: () -> Unit /* this */
/**
         * @deprecated
         */
var atan2: (b: MathNodeParameter) -> MathNode
/**
         * @deprecated
         */
var atan2Assign: (b: MathNodeParameter) -> Unit /* this */
var min: Function<MathNode> /* (y: MathNodeParameter, ...values: MathNodeParameter[]) => MathNode */
var minAssign: Function<Unit /* this */> /* (y: MathNodeParameter, ...values: MathNodeParameter[]) => this */
var max: Function<MathNode> /* (y: MathNodeParameter, ...values: MathNodeParameter[]) => MathNode */
var maxAssign: Function<Unit /* this */> /* (y: MathNodeParameter, ...values: MathNodeParameter[]) => this */
var step: (b: MathNodeParameter) -> MathNode
var stepAssign: (b: MathNodeParameter) -> Unit /* this */
var reflect: (b: MathNodeParameter) -> MathNode
var reflectAssign: (b: MathNodeParameter) -> Unit /* this */
var distance: (b: MathNodeParameter) -> MathNode
var distanceAssign: (b: MathNodeParameter) -> Unit /* this */
var dot: (b: MathNodeParameter) -> MathNode
var dotAssign: (b: MathNodeParameter) -> Unit /* this */
var cross: (y: Node) -> MathNode
var crossAssign: (y: Node) -> Unit /* this */
var pow: (b: MathNodeParameter) -> MathNode
var powAssign: (b: MathNodeParameter) -> Unit /* this */
var pow2: () -> MathNode
var pow2Assign: () -> Unit /* this */
var pow3: () -> MathNode
var pow3Assign: () -> Unit /* this */
var pow4: () -> MathNode
var pow4Assign: () -> Unit /* this */
var transformDirection: (b: MathNodeParameter) -> MathNode
var transformDirectionAssign: (b: MathNodeParameter) -> Unit /* this */
var mix: (b: MathNodeParameter, c: MathNodeParameter) -> MathNode
var mixAssign: (b: MathNodeParameter, c: MathNodeParameter) -> Unit /* this */
var clamp: (b: MathNodeParameter? /* use undefined for default */, c: MathNodeParameter? /* use undefined for default */) -> MathNode
var clampAssign: (b: MathNodeParameter? /* use undefined for default */, c: MathNodeParameter? /* use undefined for default */) -> Unit /* this */
var refract: (b: MathNodeParameter, c: MathNodeParameter) -> MathNode
var refractAssign: (b: MathNodeParameter, c: MathNodeParameter) -> Unit /* this */
var smoothstep: (b: MathNodeParameter, c: MathNodeParameter) -> MathNode
var smoothstepAssign: (b: MathNodeParameter, c: MathNodeParameter) -> Unit /* this */
var faceForward: (b: MathNodeParameter, c: MathNodeParameter) -> MathNode
var faceForwardAssign: (b: MathNodeParameter, c: MathNodeParameter) -> Unit /* this */
var difference: (b: MathNodeParameter) -> MathNode
var differenceAssign: (b: MathNodeParameter) -> Unit /* this */
var saturate: () -> MathNode
var saturateAssign: () -> Unit /* this */
var cbrt: () -> MathNode
var cbrtAssign: () -> Unit /* this */
var transpose: () -> MathNode
var transposeAssign: () -> Unit /* this */
var determinant: () -> MathNode
var determinantAssign: () -> Unit /* this */
var inverse: () -> MathNode
var inverseAssign: () -> Unit /* this */
var rand: () -> OperatorNode
var randAssign: () -> Unit /* this */
var toInspector: (name: String? /* use undefined for default */, callback: ((node: Unit /* this */) -> Node)? /* use undefined for default */) -> Unit /* this */
var toInspectorAssign: (name: String? /* use undefined for default */, callback: ((node: Unit /* this */) -> Node)? /* use undefined for default */) -> Unit /* this */
var select: (ifNode: Any /* Node | number */, elseNode: Any? /* Node | number | null */ /* use undefined for default */) -> Node
var selectAssign: (ifNode: Any /* Node | number */, elseNode: Any? /* Node | number | null */ /* use undefined for default */) -> Unit /* this */
var discard: () -> Node
var discardAssign: () -> Unit /* this */
companion object {
val type: String
}
}

/* export default Node; */
external interface NodeJSONMetaTextures {
operator fun get(key: String): Any?

operator fun set(key: String, value: Any?)
}

external interface NodeJSONMetaImages {
operator fun get(key: String): Any?

operator fun set(key: String, value: Any?)
}

external interface NodeJSONMetaNodes {
operator fun get(key: String): NodeJSONIntermediateOutputData?

operator fun set(key: String, value: NodeJSONIntermediateOutputData?)
}

external interface Temp110 {
operator fun get(key: String): Any?

operator fun set(key: String, value: Any?)
}

external interface Temp111 {
operator fun get(key: String): Node?

operator fun set(key: String, value: Node?)
}

external interface NodeJSONInputDataMeta {
var textures: Temp110
var nodes: Temp111
}

external interface Temp112: JsAny {
var dispose: JsAny
}

sealed external interface NodeGetElementTypeResult {
companion object {
@seskar.js.JsValue("bool")
val bool: NodeGetElementTypeResult
@seskar.js.JsValue("int")
val int: NodeGetElementTypeResult
@seskar.js.JsValue("float")
val float: NodeGetElementTypeResult
@seskar.js.JsValue("vec2")
val vec2: NodeGetElementTypeResult
@seskar.js.JsValue("vec3")
val vec3: NodeGetElementTypeResult
@seskar.js.JsValue("vec4")
val vec4: NodeGetElementTypeResult
@seskar.js.JsValue("uint")
val uint: NodeGetElementTypeResult
}
}
