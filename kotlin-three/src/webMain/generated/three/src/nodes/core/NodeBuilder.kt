// Generated by Karakum - do not modify it manually!

@file:JsModule("threethree")

package three.src.nodes.core

// unhandled import: BufferGeometry from "../../core/BufferGeometry.js"
// unhandled import: Object3D from "../../core/Object3D.js"
// unhandled import: Material from "../../materials/Material.js"
// unhandled import: default as Renderer from "../../renderers/common/Renderer.js"
// unhandled import: Texture from "../../textures/Texture.js"
// unhandled import: default as LightsNode from "../lighting/LightsNode.js"
// unhandled import: NodeShaderStage from "./constants.js"
// unhandled import: default as Node from "./Node.js"
// unhandled import: default as NodeAttribute from "./NodeAttribute.js"
// unhandled import: default as NodeCache from "./NodeCache.js"
// unhandled import: default as NodeParser from "./NodeParser.js"
// unhandled import: default as NodeUniform from "./NodeUniform.js"
// unhandled import: default as NodeVar from "./NodeVar.js"
// unhandled import: default as NodeVarying from "./NodeVarying.js"
// unhandled import: default as StackNode from "./StackNode.js"































sealed external interface BuildStageOption {
companion object {
@seskar.js.JsValue("construct")
val construct: BuildStageOption
@seskar.js.JsValue("analyze")
val analyze: BuildStageOption
@seskar.js.JsValue("generate")
val generate: BuildStageOption
}
}

external interface FlowData {
var code: String
}

external interface NodeData {
var vertex: NodeDataVertex
var fragment: NodeDataFragment
var compute: NodeDataCompute
}

external interface NodeBuilderContext {
operator fun get(key: String): Any?

operator fun set(key: String, value: Any?)
}

external class NodeBuilder {
var `object`: Object3D
var material: Material
var geometry: BufferGeometry
var renderer: Renderer
var parser: NodeParser
var nodes: js.array.ReadonlyArray<Node>
var updateNodes: js.array.ReadonlyArray<Node>
var hashNodes: NodeBuilderHashNodes
var lightsNode: LightsNode
var fogNode: Node
var vertexShader: String
var fragmentShader: String
var computeShader: String
var cache: NodeCache
var globalCache: NodeCache
/**
     * @TODO used to be missing. check the actual type later
     */
var flowsData: Any?
var shaderStage: NodeShaderStage?
var buildStage: BuildStageOption?
var stack: StackNode
fun setHashNode(node: Node, hash: String): Unit
fun addNode(node: Node): Unit
val currentNode: Node
fun isFilteredTexture(texture: Texture): Boolean
fun getMethod(method: String): String
fun getNodeFromHash(hash: String): Node
fun addFlow(shaderStage: NodeShaderStage, node: Node): Node
fun setContext(context: NodeBuilderContext): Unit
fun getContext(): NodeBuilderContext
fun setCache(cache: NodeCache): Unit
fun getCache(): NodeCache
fun getCacheFromNode(node: Node, parent: Boolean = definedExternally): NodeCache
fun isAvailable(name: String): Boolean
fun getInstanceIndex(): String
fun getDrawIndex(): String?
fun getFrontFacing(): String
fun getFragCoord(): String
fun isFlipY(): Boolean
// @TODO: rename to .generateConst()
fun getConst(type: String, value: Any? = definedExternally): Node
fun getType(type: String): String
fun generateMethod(method: String): String
fun getAttribute(name: String, type: String): NodeAttribute
fun <TValue> getPropertyName(node: NodeVar, shaderStage: NodeShaderStage): String

fun <TValue> getPropertyName(node: NodeUniform<TValue>, shaderStage: NodeShaderStage): String
fun isVector(type: String): Boolean
fun isMatrix(type: String): Boolean
fun isReference(type: String): Boolean
fun getElementType(type: String): String?
fun getComponentType(type: String): String?
fun getVectorType(type: String): String
fun getTypeFromLength(length: Double): String
fun getTypeLength(type: String): Double
fun getVectorFromMatrix(type: String): String
fun getDataFromNode(node: Node, shaderStage: NodeShaderStage = definedExternally): NodeData
fun getNodeProperties(node: Node, shaderStage: NodeShaderStage = definedExternally): NodeBuilderGetNodePropertiesResult
fun getUniformFromNode(node: Node, type: String, shaderStage: NodeShaderStage = definedExternally, name: String? = definedExternally): NodeUniform<String>
fun getVarFromNode(node: Node, type: String, shaderStage: NodeShaderStage = definedExternally): NodeVar
fun getVaryFromNode(node: Node, type: String): NodeVarying
fun getCodeFromNode(node: Node, type: String, shaderStage: NodeShaderStage = definedExternally): String
fun addFlowCode(code: String): Unit
fun getFlowData(node: Node, shaderStage: NodeShaderStage): FlowData
fun flowNode(node: Node): FlowData
fun flowChildNode(node: Node, output: String? = definedExternally): FlowData
fun flowNodeFromShaderStage(shaderStage: NodeShaderStage, node: Node, output: String? = definedExternally, propertyName: String = definedExternally): FlowData
fun hasGeometryAttribute(name: String): Boolean
fun getAttributes(shaderStage: NodeShaderStage): String
fun getVaryings(shaderStage: NodeShaderStage): String
fun getVars(shaderStage: NodeShaderStage): String
fun getUniforms(stage: NodeShaderStage): String
fun getCodes(shaderStage: NodeShaderStage): String
fun getHash(): String
fun setShaderStage(shaderStage: NodeShaderStage): Unit
fun getShaderStage(): NodeShaderStage
fun setBuildStage(buildStage: BuildStageOption): Unit
fun getBuildStage(): BuildStageOption
fun buildCode(): Unit
fun build(): Unit /* this */
fun format(snippet: String, fromType: String, toType: String): String
fun getSignature(): String
}
external interface NodeDataVertex {
operator fun get(key: String): Any?

operator fun set(key: String, value: Any?)
}

external interface NodeDataFragment {
operator fun get(key: String): Any?

operator fun set(key: String, value: Any?)
}

external interface NodeDataCompute {
operator fun get(key: String): Any?

operator fun set(key: String, value: Any?)
}

external interface NodeBuilderHashNodes {
operator fun get(key: String): Node?

operator fun set(key: String, value: Node?)
}

external interface NodeBuilderGetNodePropertiesResult {
operator fun get(key: String): Any?

operator fun set(key: String, value: Any?)
}