// Generated by Karakum - do not modify it manually!

@file:JsModule("threethree")

package three.src.core

// unhandled import: Box3 from "../math/Box3.js"
// unhandled import: Matrix4 from "../math/Matrix4.js"
// unhandled import: Quaternion from "../math/Quaternion.js"
// unhandled import: Sphere from "../math/Sphere.js"
// unhandled import: Vector2 from "../math/Vector2.js"
// unhandled import: Vector3 from "../math/Vector3.js"
// unhandled import: Vector3Tuple from "../math/Vector3.js"
// unhandled import: default as IndirectStorageBufferAttribute from "../renderers/common/IndirectStorageBufferAttribute.js"
// unhandled import: BufferAttribute from "./BufferAttribute.js"
// unhandled import: BufferAttributeJSON from "./BufferAttribute.js"
// unhandled import: EventDispatcher from "./EventDispatcher.js"
// unhandled import: GLBufferAttribute from "./GLBufferAttribute.js"
// unhandled import: InterleavedBufferAttribute from "./InterleavedBufferAttribute.js"























typealias NormalBufferAttributes = Record<String, Any /* BufferAttribute | InterleavedBufferAttribute */>

typealias NormalOrGLBufferAttributes = Record<String, Any /* BufferAttribute | InterleavedBufferAttribute | GLBufferAttribute */>

external interface BufferGeometryJSON {
var metadata: (BufferGeometryJSONMetadata)?
var uuid: String
var type: String
var name: String?
var userData: Record<String, Any?>?
var data: (BufferGeometryJSONData)?
}

external interface GeometryGroup {
/**
     * Specifies the first element in this draw call – the first vertex for non-indexed geometry, otherwise the first triangle index.
     * @remarks Expects a `Integer`
     */
var start: Double
/**
     * Specifies how many vertices (or indices) are included.
     * @remarks Expects a `Integer`
     */
var count: Double
/**
     * Specifies the material array index to use.
     * @remarks Expects a `Integer`
     */
var materialIndex: Double?
}

external interface BufferGeometryEventMap {
var dispose: Any
}

/**
 * A representation of mesh, line, or point geometry
 * Includes vertex positions, face indices, normals, colors, UVs, and custom attributes within buffers, reducing the cost of passing all this data to the GPU.
 * @remarks
 * To read and edit data in BufferGeometry attributes, see {@link THREE.BufferAttribute | BufferAttribute} documentation.
 * @example
 * ```typescript
 * const geometry = new THREE.BufferGeometry();
 *
 * // create a simple square shape. We duplicate the top left and bottom right
 * // vertices because each vertex needs to appear once per triangle.
 * const vertices = new Float32Array( [
 *   -1.0, -1.0,  1.0, // v0
 *    1.0, -1.0,  1.0, // v1
 *    1.0,  1.0,  1.0, // v2
 *
 *    1.0,  1.0,  1.0, // v3
 *   -1.0,  1.0,  1.0, // v4
 *   -1.0, -1.0,  1.0  // v5
 * ] );
 *
 * // itemSize = 3 because there are 3 values (components) per vertex
 * geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
 * const material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
 * const mesh = new THREE.Mesh( geometry, material );
 * ```
 * @example
 * ```typescript
 * const geometry = new THREE.BufferGeometry();
 *
 * const vertices = new Float32Array( [
 *   -1.0, -1.0,  1.0, // v0
 *    1.0, -1.0,  1.0, // v1
 *    1.0,  1.0,  1.0, // v2
 *   -1.0,  1.0,  1.0, // v3
 * ] );
 * geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
 *
 * const indices = [
 *   0, 1, 2,
 *   2, 3, 0,
 * ];
 *
 * geometry.setIndex( indices );
 * geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
 *
 * const material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
 * const mesh = new THREE.Mesh( geometry, material );
 * ```
 * @see Example: {@link https://threejs.org/examples/#webgl_buffergeometry | Mesh with non-indexed faces}
 * @see Example: {@link https://threejs.org/examples/#webgl_buffergeometry_indexed | Mesh with indexed faces}
 * @see Example: {@link https://threejs.org/examples/#webgl_buffergeometry_lines | Lines}
 * @see Example: {@link https://threejs.org/examples/#webgl_buffergeometry_lines_indexed | Indexed Lines}
 * @see Example: {@link https://threejs.org/examples/#webgl_buffergeometry_custom_attributes_particles | Particles}
 * @see Example: {@link https://threejs.org/examples/#webgl_buffergeometry_rawshader | Raw Shaders}
 * @see {@link https://threejs.org/docs/index.html#api/en/core/BufferGeometry | Official Documentation}
 * @see {@link https://github.com/mrdoob/three.js/blob/master/src/core/BufferGeometry.js | Source}
 */
external class BufferGeometry<Attributes : NormalOrGLBufferAttributes /* default is NormalBufferAttributes */, TEventMap : BufferGeometryEventMap /* default is BufferGeometryEventMap */> : EventDispatcher<TEventMap> {
/**
     * This creates a new {@link THREE.BufferGeometry | BufferGeometry} object.
     */
constructor ()
/**
     * Unique number for this {@link THREE.BufferGeometry | BufferGeometry} instance.
     * @remarks Expects a `Integer`
     */
var id: Double
/**
     * {@link http://en.wikipedia.org/wiki/Universally_unique_identifier | UUID} of this object instance.
     * @remarks This gets automatically assigned and shouldn't be edited.
     */
var uuid: String
/**
     * Optional name for this {@link THREE.BufferGeometry | BufferGeometry} instance.
     * @defaultValue `''`
     */
var name: String
/**
     * A Read-only _string_ to check if `this` object type.
     * @remarks Sub-classes will update this value.
     * @defaultValue `BufferGeometry`
     */
val type: Any /* string | "BufferGeometry" */
/**
     * Allows for vertices to be re-used across multiple triangles; this is called using "indexed triangles".
     * Each triangle is associated with the indices of three vertices. This attribute therefore stores the index of each vertex for each triangular face.
     * If this attribute is not set, the {@link THREE.WebGLRenderer | renderer}  assumes that each three contiguous positions represent a single triangle.
     * @defaultValue `null`
     */
var index: BufferAttribute?
var indirect: IndirectStorageBufferAttribute?
var indirectOffset: Any /* number | number[] */
/**
     * This hashmap has as id the name of the attribute to be set and as value the {@link THREE.BufferAttribute | buffer} to set it to. Rather than accessing this property directly,
     * use {@link setAttribute | .setAttribute} and {@link getAttribute | .getAttribute} to access attributes of this geometry.
     * @defaultValue `{}`
     */
var attributes: Attributes
/**
     * Hashmap of {@link THREE.BufferAttribute | BufferAttributes} holding details of the geometry's morph targets.
     * @remarks
     * Once the geometry has been rendered, the morph attribute data cannot be changed.
     * You will have to call {@link dispose | .dispose}(), and create a new instance of {@link THREE.BufferGeometry | BufferGeometry}.
     * @defaultValue `{}`
     */
var morphAttributes: BufferGeometryMorphAttributes
/**
     * Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals.
     * @defaultValue `false`
     */
var morphTargetsRelative: Boolean
/**
     * Split the geometry into groups, each of which will be rendered in a separate WebGL draw call. This allows an array of materials to be used with the geometry.
     * @remarks Every vertex and index must belong to exactly one group — groups must not share vertices or indices, and must not leave vertices or indices unused.
     * @remarks Use {@link addGroup | .addGroup} to add groups, rather than modifying this array directly.
     * @defaultValue `[]`
     */
var groups: js.array.ReadonlyArray<GeometryGroup>
/**
     * Bounding box for the {@link THREE.BufferGeometry | BufferGeometry}, which can be calculated with {@link computeBoundingBox | .computeBoundingBox()}.
     * @remarks Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are `null`.
     * @defaultValue `null`
     */
var boundingBox: Box3?
/**
     * Bounding sphere for the {@link THREE.BufferGeometry | BufferGeometry}, which can be calculated with {@link computeBoundingSphere | .computeBoundingSphere()}.
     * @remarks bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are `null`.
     * @defaultValue `null`
     */
var boundingSphere: Sphere?
/**
     * Determines the part of the geometry to render. This should not be set directly, instead use {@link setDrawRange | .setDrawRange(...)}.
     * @remarks For non-indexed {@link THREE.BufferGeometry | BufferGeometry}, count is the number of vertices to render.
     * @remarks For indexed {@link THREE.BufferGeometry | BufferGeometry}, count is the number of indices to render.
     * @defaultValue `{ start: 0, count: Infinity }`
     */
var drawRange: BufferGeometryDrawRange
/**
     * An object that can be used to store custom data about the BufferGeometry. It should not hold references to functions as these will not be cloned.
     * @defaultValue `{}`
     */
var userData: Record<String, Any?>
/**
     * Read-only flag to check if a given object is of type {@link BufferGeometry}.
     * @remarks This is a _constant_ value
     * @defaultValue `true`
     */
val isBufferGeometry: Boolean /* true */
/**
     * Return the {@link index | .index} buffer.
     */
fun getIndex(): BufferAttribute?
/**
     * Set the {@link THREE.BufferGeometry.index | .index} buffer.
     * @param index
     */
fun setIndex(index: BufferAttribute?): Unit /* this */

/**
     * Set the {@link THREE.BufferGeometry.index | .index} buffer.
     * @param index
     */
fun setIndex(index: js.array.ReadonlyArray<Double>?): Unit /* this */
fun setIndirect(indirect: IndirectStorageBufferAttribute?): Unit /* this */

fun setIndirect(indirect: IndirectStorageBufferAttribute?, indirectOffset: Double = definedExternally): Unit /* this */

fun setIndirect(indirect: IndirectStorageBufferAttribute?, indirectOffset: js.array.ReadonlyArray<Double> = definedExternally): Unit /* this */
fun getIndirect(): IndirectStorageBufferAttribute?
/**
     * Sets an {@link attributes | attribute} to this geometry with the specified name.
     * @remarks
     * Use this rather than the attributes property, because an internal hashmap of {@link attributes | .attributes} is maintained to speed up iterating over attributes.
     * @param name
     * @param attribute
     */
fun <K : /* keyof Attributes */> setAttribute(name: K, attribute: Any?): Unit /* this */
/**
     * Returns the {@link attributes | attribute} with the specified name.
     * @param name
     */
fun <K : /* keyof Attributes */> getAttribute(name: K): Any?
/**
     * Deletes the  {@link attributes | attribute} with the specified name.
     * @param name
     */
fun deleteAttribute(name: /* keyof Attributes */): Unit /* this */
/**
     * Returns true if the {@link attributes | attribute} with the specified name exists.
     * @param name
     */
fun hasAttribute(name: /* keyof Attributes */): Boolean
/**
     * Adds a group to this geometry
     * @see the {@link BufferGeometry.groups | groups} property for details.
     * @param start
     * @param count
     * @param materialIndex
     */
fun addGroup(start: Double, count: Double, materialIndex: Double = definedExternally): Unit
/**
     * Clears all groups.
     */
fun clearGroups(): Unit
/**
     * Set the {@link drawRange | .drawRange} property
     * @remarks For non-indexed BufferGeometry, count is the number of vertices to render
     * @remarks For indexed BufferGeometry, count is the number of indices to render.
     * @param start
     * @param count is the number of vertices or indices to render. Expects a `Integer`
     */
fun setDrawRange(start: Double, count: Double): Unit
/**
     * Applies the matrix transform to the geometry.
     * @param matrix
     */
fun applyMatrix4(matrix: Matrix4): Unit /* this */
/**
     * Applies the rotation represented by the quaternion to the geometry.
     * @param quaternion
     */
fun applyQuaternion(quaternion: Quaternion): Unit /* this */
/**
     * Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.
     * @remarks Use {@link THREE.Object3D.rotation | Object3D.rotation} for typical real-time mesh rotation.
     * @param angle radians. Expects a `Float`
     */
fun rotateX(angle: Double): Unit /* this */
/**
     * Rotate the geometry about the Y axis.
     * @remarks This is typically done as a one time operation, and not during a loop.
     * @remarks Use {@link THREE.Object3D.rotation | Object3D.rotation} for typical real-time mesh rotation.
     * @param angle radians. Expects a `Float`
     */
fun rotateY(angle: Double): Unit /* this */
/**
     * Rotate the geometry about the Z axis.
     * @remarks This is typically done as a one time operation, and not during a loop.
     * @remarks Use {@link THREE.Object3D.rotation | Object3D.rotation} for typical real-time mesh rotation.
     * @param angle radians. Expects a `Float`
     */
fun rotateZ(angle: Double): Unit /* this */
/**
     * Translate the geometry.
     * @remarks This is typically done as a one time operation, and not during a loop.
     * @remarks Use {@link THREE.Object3D.position | Object3D.position} for typical real-time mesh rotation.
     * @param x Expects a `Float`
     * @param y Expects a `Float`
     * @param z Expects a `Float`
     */
fun translate(x: Double, y: Double, z: Double): Unit /* this */
/**
     * Scale the geometry data.
     * @remarks This is typically done as a one time operation, and not during a loop.
     * @remarks Use {@link THREE.Object3D.scale | Object3D.scale} for typical real-time mesh scaling.
     * @param x Expects a `Float`
     * @param y Expects a `Float`
     * @param z Expects a `Float`
     */
fun scale(x: Double, y: Double, z: Double): Unit /* this */
/**
     * Rotates the geometry to face a point in space.
     * @remarks This is typically done as a one time operation, and not during a loop.
     * @remarks Use {@link THREE.Object3D.lookAt | Object3D.lookAt} for typical real-time mesh usage.
     * @param vector A world vector to look at.
     */
fun lookAt(vector: Vector3): Unit /* this */
/**
     * Center the geometry based on the bounding box.
     */
fun center(): Unit /* this */
/**
     * Defines a geometry by creating a `position` attribute based on the given array of points. The array can hold
     * instances of {@link Vector2} or {@link Vector3}. When using two-dimensional data, the `z` coordinate for all
     * vertices is set to `0`.
     *
     * If the method is used with an existing `position` attribute, the vertex data are overwritten with the data from
     * the array. The length of the array must match the vertex count.
     */
fun setFromPoints(points: js.array.ReadonlyArray<Vector3>): Unit /* this */

/**
     * Defines a geometry by creating a `position` attribute based on the given array of points. The array can hold
     * instances of {@link Vector2} or {@link Vector3}. When using two-dimensional data, the `z` coordinate for all
     * vertices is set to `0`.
     *
     * If the method is used with an existing `position` attribute, the vertex data are overwritten with the data from
     * the array. The length of the array must match the vertex count.
     */
fun setFromPoints(points: js.array.ReadonlyArray<Vector2>): Unit /* this */
/**
     * Computes the bounding box of the geometry, and updates the {@link .boundingBox} attribute. The bounding box is
     * not computed by the engine; it must be computed by your app. You may need to recompute the bounding box if the
     * geometry vertices are modified.
     */
fun computeBoundingBox(): Unit
/**
     * Computes the bounding sphere of the geometry, and updates the {@link .boundingSphere} attribute. The engine
     * automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling. You
     * may need to recompute the bounding sphere if the geometry vertices are modified.
     */
fun computeBoundingSphere(): Unit
/**
     * Calculates and adds a tangent attribute to this geometry.
     * The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined
     * @remarks
     * When using a tangent space normal map, prefer the MikkTSpace algorithm provided by
     * {@link BufferGeometryUtils.computeMikkTSpaceTangents} instead.
     */
fun computeTangents(): Unit
/**
     * Computes vertex normals for the given vertex data. For indexed geometries, the method sets each vertex normal to
     * be the average of the face normals of the faces that share that vertex. For non-indexed geometries, vertices are
     * not shared, and the method sets each vertex normal to be the same as the face normal.
     */
fun computeVertexNormals(): Unit
/**
     * Every normal vector in a geometry will have a magnitude of 1
     * @remarks This will correct lighting on the geometry surfaces.
     */
fun normalizeNormals(): Unit
/**
     * Return a non-index version of an indexed BufferGeometry.
     */
fun toNonIndexed(): BufferGeometry
/**
     * Convert the buffer geometry to three.js {@link https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 | JSON Object/Scene format}.
     */
fun toJSON(): BufferGeometryJSON
/**
     * Creates a clone of this BufferGeometry
     */
fun clone(): Unit /* this */
/**
     * Copies another BufferGeometry to this BufferGeometry.
     * @param source
     */
fun copy(source: BufferGeometry): Unit /* this */
/**
     * Frees the GPU-related resources allocated by this instance.
     * @remarks Call this method whenever this instance is no longer used in your app.
     */
fun dispose(): Unit
}
external interface BufferGeometryJSONMetadata {
var version: Double
var type: String
var generator: String
}

external interface Temp3 {
var type: String
var array: js.array.ReadonlyArray<Double>
}

external interface Temp4 {
var center: Vector3Tuple
var radius: Double
}

external interface BufferGeometryJSONData {
var attributes: Record<String, BufferAttributeJSON>
var index: (Temp3)?
var morphAttributes: Record<String, js.array.ReadonlyArray<BufferAttributeJSON>>?
var morphTargetsRelative: Boolean?
var groups: js.array.ReadonlyArray<GeometryGroup>?
var boundingSphere: (Temp4)?
}

external interface BufferGeometryMorphAttributes {
var position: Array<Any /* BufferAttribute | InterleavedBufferAttribute */>?
var normal: Array<Any /* BufferAttribute | InterleavedBufferAttribute */>?
var color: Array<Any /* BufferAttribute | InterleavedBufferAttribute */>?
}

external interface BufferGeometryDrawRange {
var start: Double
var count: Double
}