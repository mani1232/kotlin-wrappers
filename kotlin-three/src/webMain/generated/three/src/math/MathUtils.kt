// Generated by Karakum - do not modify it manually!

@file:JsModule("threethree")

package three.src.math

// unhandled import: Quaternion from "./Quaternion.js"



/**
 * @see {@link https://github.com/mrdoob/three.js/blob/master/src/math/MathUtils.js|src/math/MathUtils.js}
 */
external val DEG2RAD: Double

external val RAD2DEG: Double

external fun generateUUID(): String

/**
 * Clamps the x to be between a and b.
 *
 * @param value Value to be clamped.
 * @param min Minimum value.
 * @param max Maximum value.
 */
external fun clamp(value: Double, min: Double, max: Double): Double

external fun euclideanModulo(n: Double, m: Double): Double

/**
 * Linear mapping of x from range [a1, a2] to range [b1, b2].
 *
 * @param x Value to be mapped.
 * @param a1 Minimum value for range A.
 * @param a2 Maximum value for range A.
 * @param b1 Minimum value for range B.
 * @param b2 Maximum value for range B.
 */
external fun mapLinear(x: Double, a1: Double, a2: Double, b1: Double, b2: Double): Double

external fun inverseLerp(x: Double, y: Double, t: Double): Double

/**
 * Returns a value linearly interpolated from two known points based
 * on the given interval - t = 0 will return x and t = 1 will return y.
 *
 * @param x Start point.
 * @param y End point.
 * @param t interpolation factor in the closed interval [0, 1]
 */
external fun lerp(x: Double, y: Double, t: Double): Double

/**
 * Smoothly interpolate a number from x toward y in a spring-like
 * manner using the dt to maintain frame rate independent movement.
 *
 * @param x Current point.
 * @param y Target point.
 * @param lambda A higher lambda value will make the movement more sudden, and a lower value will make the movement more gradual.
 * @param dt Delta time in seconds.
 */
external fun damp(x: Double, y: Double, lambda: Double, dt: Double): Double

/**
 * Returns a value that alternates between 0 and length.
 *
 * @param x The value to pingpong.
 * @param length The positive value the export function will pingpong to. Default is 1.
 */
external fun pingpong(x: Double, length: Double = definedExternally): Double

external fun smoothstep(x: Double, min: Double, max: Double): Double

external fun smootherstep(x: Double, min: Double, max: Double): Double

/**
 * Random integer from low to high interval.
 */
external fun randInt(low: Double, high: Double): Double

/**
 * Random float from low to high interval.
 */
external fun randFloat(low: Double, high: Double): Double

/**
 * Random float from - range / 2 to range / 2 interval.
 */
external fun randFloatSpread(range: Double): Double

/**
 * Deterministic pseudo-random float in the interval [ 0, 1 ].
 */
external fun seededRandom(seed: Double = definedExternally): Double

external fun degToRad(degrees: Double): Double

external fun radToDeg(radians: Double): Double

external fun isPowerOfTwo(value: Double): Boolean

external fun ceilPowerOfTwo(value: Double): Double

external fun floorPowerOfTwo(value: Double): Double

external fun setQuaternionFromProperEuler(q: Quaternion, a: Double, b: Double, c: Double, order: String): Unit

external fun denormalize(value: Double, array: Float32Array): Double

external fun denormalize(value: Double, array: Uint32Array): Double

external fun denormalize(value: Double, array: Uint16Array): Double

external fun denormalize(value: Double, array: Uint8Array): Double

external fun denormalize(value: Double, array: Int32Array): Double

external fun denormalize(value: Double, array: Int16Array): Double

external fun denormalize(value: Double, array: Int8Array): Double

external fun normalize(value: Double, array: Float32Array): Double

external fun normalize(value: Double, array: Uint32Array): Double

external fun normalize(value: Double, array: Uint16Array): Double

external fun normalize(value: Double, array: Uint8Array): Double

external fun normalize(value: Double, array: Int32Array): Double

external fun normalize(value: Double, array: Int16Array): Double

external fun normalize(value: Double, array: Int8Array): Double

external val MathUtils: MathUtils
external interface MathUtils {
var DEG2RAD: Double
var RAD2DEG: Double
var generateUUID: () -> String
var clamp: (value: Double, min: Double, max: Double) -> Double
var euclideanModulo: (n: Double, m: Double) -> Double
var mapLinear: (x: Double, a1: Double, a2: Double, b1: Double, b2: Double) -> Double
var inverseLerp: (x: Double, y: Double, t: Double) -> Double
var lerp: (x: Double, y: Double, t: Double) -> Double
var damp: (x: Double, y: Double, lambda: Double, dt: Double) -> Double
var pingpong: (x: Double, length: Double? /* use undefined for default */) -> Double
var smoothstep: (x: Double, min: Double, max: Double) -> Double
var smootherstep: (x: Double, min: Double, max: Double) -> Double
var randInt: (low: Double, high: Double) -> Double
var randFloat: (low: Double, high: Double) -> Double
var randFloatSpread: (range: Double) -> Double
var seededRandom: (seed: Double? /* use undefined for default */) -> Double
var degToRad: (degrees: Double) -> Double
var radToDeg: (radians: Double) -> Double
var isPowerOfTwo: (value: Double) -> Boolean
var ceilPowerOfTwo: (value: Double) -> Double
var floorPowerOfTwo: (value: Double) -> Double
var setQuaternionFromProperEuler: (q: Quaternion, a: Double, b: Double, c: Double, order: String) -> Unit
var normalize: (value: Double, array: Any /* Float32Array<ArrayBufferLike> | Uint32Array<ArrayBufferLike> | Uint16Array<ArrayBufferLike> | Uint8Array<ArrayBufferLike> | Int32Array<ArrayBufferLike> | Int16Array<ArrayBufferLike> | Int8Array<ArrayBufferLike> */) -> Double
var denormalize: (value: Double, array: Any /* Float32Array<ArrayBufferLike> | Uint32Array<ArrayBufferLike> | Uint16Array<ArrayBufferLike> | Uint8Array<ArrayBufferLike> | Int32Array<ArrayBufferLike> | Int16Array<ArrayBufferLike> | Int8Array<ArrayBufferLike> */) -> Double
}