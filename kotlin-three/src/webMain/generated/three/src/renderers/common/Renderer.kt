// Generated by Karakum - do not modify it manually!

@file:JsModule("threethree")

package three.src.renderers.common

// unhandled import: Camera from "../../cameras/Camera.js"
// unhandled import: ShadowMapType from "../../constants.js"
// unhandled import: TextureDataType from "../../constants.js"
// unhandled import: TimestampQuery from "../../constants.js"
// unhandled import: ToneMapping from "../../constants.js"
// unhandled import: BufferAttribute from "../../core/BufferAttribute.js"
// unhandled import: BufferGeometry from "../../core/BufferGeometry.js"
// unhandled import: GeometryGroup from "../../core/BufferGeometry.js"
// unhandled import: Object3D from "../../core/Object3D.js"
// unhandled import: RenderTarget from "../../core/RenderTarget.js"
// unhandled import: Material from "../../materials/Material.js"
// unhandled import: Box2 from "../../math/Box2.js"
// unhandled import: Box3 from "../../math/Box3.js"
// unhandled import: ColorRepresentation from "../../math/Color.js"
// unhandled import: Vector2 from "../../math/Vector2.js"
// unhandled import: Vector3 from "../../math/Vector3.js"
// unhandled import: Vector4 from "../../math/Vector4.js"
// unhandled import: default as MRTNode from "../../nodes/core/MRTNode.js"
// unhandled import: default as ComputeNode from "../../nodes/gpgpu/ComputeNode.js"
// unhandled import: default as LightsNode from "../../nodes/lighting/LightsNode.js"
// unhandled import: Group from "../../objects/Group.js"
// unhandled import: Scene from "../../scenes/Scene.js"
// unhandled import: FramebufferTexture from "../../textures/FramebufferTexture.js"
// unhandled import: Texture from "../../textures/Texture.js"
// unhandled import: default as Animation from "./Animation.js"
// unhandled import: default as Attributes from "./Attributes.js"
// unhandled import: default as Backend from "./Backend.js"
// unhandled import: default as Background from "./Background.js"
// unhandled import: default as Bindings from "./Bindings.js"
// unhandled import: default as CanvasTarget from "./CanvasTarget.js"
// unhandled import: default as ClippingContext from "./ClippingContext.js"
// unhandled import: default as Color4 from "./Color4.js"
// unhandled import: default as Geometries from "./Geometries.js"
// unhandled import: default as IndirectStorageBufferAttribute from "./IndirectStorageBufferAttribute.js"
// unhandled import: default as Info from "./Info.js"
// unhandled import: default as InspectorBase from "./InspectorBase.js"
// unhandled import: default as Lighting from "./Lighting.js"
// unhandled import: default as NodeLibrary from "./nodes/NodeLibrary.js"
// unhandled import: default as Nodes from "./nodes/Nodes.js"
// unhandled import: default as Pipelines from "./Pipelines.js"
// unhandled import: default as QuadMesh from "./QuadMesh.js"
// unhandled import: default as RenderBundle from "./RenderBundle.js"
// unhandled import: default as RenderBundles from "./RenderBundles.js"
// unhandled import: default as RenderContext from "./RenderContext.js"
// unhandled import: default as RenderContexts from "./RenderContexts.js"
// unhandled import: default as RenderList from "./RenderList.js"
// unhandled import: Bundle from "./RenderList.js"
// unhandled import: RenderItem from "./RenderList.js"
// unhandled import: default as RenderLists from "./RenderLists.js"
// unhandled import: default as RenderObjects from "./RenderObjects.js"
// unhandled import: default as Textures from "./Textures.js"
// unhandled import: default as XRManager from "./XRManager.js"





























































































external interface Rectangle {
var x: Double
var y: Double
var z: Double
var w: Double
}

external interface DeviceLostInfo {
var api: DeviceLostInfoApi
var message: String
var reason: String?
var originalEvent: Any?
}

external interface RendererParameters {
var logarithmicDepthBuffer: Boolean?
var alpha: Boolean?
var depth: Boolean?
var stencil: Boolean?
var antialias: Boolean?
var samples: Double?
var getFallback: ((error: Any?) -> Backend)?
var outputBufferType: TextureDataType?
var multiview: Boolean?
}

/**
 * Base class for renderers.
 */
external class Renderer {
/**
     * Renderer options.
     *
     * @typedef {Object} Renderer~Options
     * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
     * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
     * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
     * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
     * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
     * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. This parameter can set to any other integer value than 0
     * to overwrite the default.
     * @property {?Function} [getFallback=null] - This callback function can be used to provide a fallback backend, if the primary backend can't be targeted.
     * @property {number} [outputBufferType=HalfFloatType] - Defines the type of output buffers. The default `HalfFloatType` is recommend for best
     * quality. To save memory and bandwidth, `UnsignedByteType` might be used. This will reduce rendering quality though.
     * @property {boolean} [multiview=false] - If set to `true`, the renderer will use multiview during WebXR rendering if supported.
     */
/**
     * Constructs a new renderer.
     *
     * @param {Backend} backend - The backend the renderer is targeting (e.g. WebGPU or WebGL 2).
     * @param {Renderer~Options} [parameters] - The configuration parameter.
     */
constructor (backend: Backend, parameters: RendererParameters = definedExternally)
val isRenderer: Boolean /* true */
var backend: Backend
var autoClear: Boolean
var autoClearColor: Boolean
var autoClearDepth: Boolean
var autoClearStencil: Boolean
var alpha: Boolean
var logarithmicDepthBuffer: Boolean
var outputColorSpace: String
var toneMapping: ToneMapping
var toneMappingExposure: Double
var sortObjects: Boolean
var depth: Boolean
var stencil: Boolean
var info: Info
var library: NodeLibrary
var lighting: Lighting
var _samples: Double
var _canvasTarget: CanvasTarget
var _inspector: InspectorBase
var _getFallback: ((error: Any?) -> Backend)?
var _attributes: Attributes?
var _geometries: Geometries?
var _nodes: Nodes?
var _animation: Animation?
var _bindings: Bindings?
var _objects: RenderObjects?
var _pipelines: Pipelines?
var _bundles: RenderBundles?
var _renderLists: RenderLists?
var _renderContexts: RenderContexts?
var _textures: Textures?
var _background: Background?
var _quad: QuadMesh
var _currentRenderContext: RenderContext?
var _opaqueSort: ((a: RenderItem, b: RenderItem) -> Double)?
var _transparentSort: ((a: RenderItem, b: RenderItem) -> Double)?
var _frameBufferTarget: RenderTarget?
var _clearColor: Color4
var _clearDepth: Double
var _clearStencil: Double
var _renderTarget: RenderTarget?
var _activeCubeFace: Double
var _activeMipmapLevel: Double
var _outputRenderTarget: RenderTarget?
var _mrt: MRTNode?
var _renderObjectFunction: ((`object`: Object3D, scene: Scene, camera: Camera, geometry: BufferGeometry, material: Material, group: GeometryGroup, lightsNode: LightsNode, clippingContext: ClippingContext?, passId: String?) -> Unit)?
var _currentRenderObjectFunction: ((`object`: Object3D, scene: Scene, camera: Camera, geometry: BufferGeometry, material: Material, group: GeometryGroup, lightsNode: LightsNode, clippingContext: ClippingContext?, passId: String?) -> Unit)?
var _currentRenderBundle: RenderBundle?
var _handleObjectFunction: (`object`: Object3D, material: Material, scene: Scene, camera: Camera, lightsNode: LightsNode, group: GeometryGroup, clippingContext: ClippingContext?, passId: String? /* use undefined for default */) -> Unit
var _isDeviceLost: Boolean
var onDeviceLost: (info: DeviceLostInfo) -> Unit
var _outputBufferType: TextureDataType
var _initialized: Boolean
var _initPromise: Promise<Unit /* this */>?
var _compilationPromises: js.array.ReadonlyArray<Promise<js.core.Void>>?
var transparent: Boolean
var opaque: Boolean
var shadowMap: RendererShadowMap
var xr: XRManager
var debug: RendererDebug
var localClippingEnabled: Boolean?
/**
     * Initializes the renderer so it is ready for usage.
     *
     * @async
     * @return {Promise<this>} A Promise that resolves when the renderer has been initialized.
     */
fun init(): Promise<Unit /* this */>
/**
     * A reference to the canvas element the renderer is drawing to.
     * This value of this property will automatically be created by
     * the renderer.
     *
     * @type {HTMLCanvasElement|OffscreenCanvas}
     */
val domElement: HTMLCanvasElement
/**
     * The coordinate system of the renderer. The value of this property
     * depends on the selected backend. Either `THREE.WebGLCoordinateSystem` or
     * `THREE.WebGPUCoordinateSystem`.
     *
     * @readonly
     * @type {number}
     */
val coordinateSystem: /* import("../../constants.js") */ CoordinateSystem
/**
     * Compiles all materials in the given scene. This can be useful to avoid a
     * phenomenon which is called "shader compilation stutter", which occurs when
     * rendering an object with a new shader for the first time.
     *
     * If you want to add a 3D object to an existing scene, use the third optional
     * parameter for applying the target scene. Note that the (target) scene's lighting
     * and environment must be configured before calling this method.
     *
     * @async
     * @param {Object3D} scene - The scene or 3D object to precompile.
     * @param {Camera} camera - The camera that is used to render the scene.
     * @param {?Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.
     * @return {Promise} A Promise that resolves when the compile has been finished.
     */
fun compileAsync(scene: Object3D, camera: Camera, targetScene: Scene? = definedExternally): Promise<js.core.Void>
/**
     * Renders the scene in an async fashion.
     *
     * @async
     * @deprecated
     * @param {Object3D} scene - The scene or 3D object to render.
     * @param {Camera} camera - The camera.
     * @return {Promise} A Promise that resolves when the render has been finished.
     */
fun renderAsync(scene: Object3D, camera: Camera): Promise<js.core.Void>
/**
     * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,
     * the CPU waits for the GPU to complete its operation (e.g. a compute task).
     *
     * @async
     * @deprecated
     * @return {Promise} A Promise that resolves when synchronization has been finished.
     */
fun waitForGPU(): Promise<js.core.Void>
var inspector: InspectorBase
/**
     * Enables or disables high precision for model-view and normal-view matrices.
     * When enabled, will use CPU 64-bit precision for higher precision instead of GPU 32-bit for higher performance.
     *
     * NOTE: 64-bit precision is not compatible with `InstancedMesh` and `SkinnedMesh`.
     *
     * @param {boolean} value - Whether to enable or disable high precision.
     * @type {boolean}
     */
var highPrecision: Boolean
/**
     * Sets the given MRT configuration.
     *
     * @param {MRTNode} mrt - The MRT node to set.
     * @return {Renderer} A reference to this renderer.
     */
fun setMRT(mrt: MRTNode?): Unit /* this */
/**
     * Returns the MRT configuration.
     *
     * @return {MRTNode} The MRT configuration.
     */
fun getMRT(): MRTNode?
/**
     * Returns the output buffer type.
     *
     * @return {number} The output buffer type.
     */
fun getOutputBufferType(): TextureDataType
/**
     * Returns the output buffer type.
     *
     * @deprecated since r182. Use `.getOutputBufferType()` instead.
     * @return {number} The output buffer type.
     */
fun getColorBufferType(): TextureDataType
/**
     * Default implementation of the device lost callback.
     *
     * @private
     * @param {Object} info - Information about the context lost.
     */
fun _onDeviceLost(info: DeviceLostInfo): Unit
/**
     * Renders the given render bundle.
     *
     * @private
     * @param {Object} bundle - Render bundle data.
     * @param {Scene} sceneRef - The scene the render bundle belongs to.
     * @param {LightsNode} lightsNode - The lights node.
     */
fun _renderBundle(bundle: Bundle, sceneRef: Scene, lightsNode: LightsNode): Unit
/**
     * Renders the scene or 3D object with the given camera. This method can only be called
     * if the renderer has been initialized. When using `render()` inside an animation loop,
     * it's guaranteed the renderer will be initialized. The animation loop must be defined
     * with {@link Renderer#setAnimationLoop} though.
     *
     * For all other use cases (like when using on-demand rendering), you must call
     * {@link Renderer#init} before rendering.
     *
     * The target of the method is the default framebuffer (meaning the canvas)
     * or alternatively a render target when specified via `setRenderTarget()`.
     *
     * @param {Object3D} scene - The scene or 3D object to render.
     * @param {Camera} camera - The camera to render the scene with.
     */
fun render(scene: Object3D, camera: Camera): Unit
/**
     * Returns whether the renderer has been initialized or not.
     *
     * @readonly
     * @return {boolean} Whether the renderer has been initialized or not.
     */
val initialized: Boolean
/**
     * Returns an internal render target which is used when computing the output tone mapping
     * and color space conversion. Unlike in `WebGLRenderer`, this is done in a separate render
     * pass and not inline to achieve more correct results.
     *
     * @private
     * @return {?RenderTarget} The render target. The method returns `null` if no output conversion should be applied.
     */
fun _getFrameBufferTarget(): RenderTarget<Texture<Any?>>?
/**
     * Renders the scene or 3D object with the given camera.
     *
     * @private
     * @param {Object3D} scene - The scene or 3D object to render.
     * @param {Camera} camera - The camera to render the scene with.
     * @param {boolean} [useFrameBufferTarget=true] - Whether to use a framebuffer target or not.
     * @return {RenderContext} The current render context.
     */
fun _renderScene(scene: Object3D, camera: Camera, useFrameBufferTarget: Boolean = definedExternally): RenderContext?
fun _setXRLayerSize(width: Double, height: Double): Unit
/**
     * The output pass performs tone mapping and color space conversion.
     *
     * @private
     * @param {RenderTarget} renderTarget - The current render target.
     */
fun _renderOutput(renderTarget: RenderTarget): Unit
/**
     * Returns the maximum available anisotropy for texture filtering.
     *
     * @return {number} The maximum available anisotropy.
     */
fun getMaxAnisotropy(): Double
/**
     * Returns the active cube face.
     *
     * @return {number} The active cube face.
     */
fun getActiveCubeFace(): Double
/**
     * Returns the active mipmap level.
     *
     * @return {number} The active mipmap level.
     */
fun getActiveMipmapLevel(): Double
/**
     * Applications are advised to always define the animation loop
     * with this method and not manually with `requestAnimationFrame()`
     * for best compatibility.
     *
     * @async
     * @param {?onAnimationCallback} callback - The application's animation loop.
     * @return {Promise} A Promise that resolves when the set has been executed.
     */
fun setAnimationLoop(callback: ((time: DOMHighResTimeStamp, frame: XRFrame? /* use undefined for default */) -> Unit)?): Promise<js.core.Void>
/**
     * Returns the current animation loop callback.
     *
     * @return {?Function} The current animation loop callback.
     */
fun getAnimationLoop(): ((time: DOMHighResTimeStamp, xrFrame: XRFrame? /* use undefined for default */) -> Unit)?
/**
     * Can be used to transfer buffer data from a storage buffer attribute
     * from the GPU to the CPU in context of compute shaders.
     *
     * @async
     * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
     * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
     */
fun getArrayBufferAsync(attribute: BufferAttribute): Promise<ArrayBuffer>
/**
     * Returns the rendering context.
     *
     * @return {GPUCanvasContext|WebGL2RenderingContext} The rendering context.
     */
fun getContext(): Unit
/**
     * Returns the pixel ratio.
     *
     * @return {number} The pixel ratio.
     */
fun getPixelRatio(): Double
/**
     * Returns the drawing buffer size in physical pixels. This method honors the pixel ratio.
     *
     * @param {Vector2} target - The method writes the result in this target object.
     * @return {Vector2} The drawing buffer size.
     */
fun getDrawingBufferSize(target: Vector2): Vector2
/**
     * Returns the renderer's size in logical pixels. This method does not honor the pixel ratio.
     *
     * @param {Vector2} target - The method writes the result in this target object.
     * @return {Vector2} The renderer's size in logical pixels.
     */
fun getSize(target: Vector2): Vector2
/**
     * Sets the given pixel ratio and resizes the canvas if necessary.
     *
     * @param {number} [value=1] - The pixel ratio.
     */
fun setPixelRatio(value: Double = definedExternally): Unit
/**
     * This method allows to define the drawing buffer size by specifying
     * width, height and pixel ratio all at once. The size of the drawing
     * buffer is computed with this formula:
     * ```js
     * size.x = width * pixelRatio;
     * size.y = height * pixelRatio;
     * ```
     *
     * @param {number} width - The width in logical pixels.
     * @param {number} height - The height in logical pixels.
     * @param {number} pixelRatio - The pixel ratio.
     */
fun setDrawingBufferSize(width: Double, height: Double, pixelRatio: Double): Unit
/**
     * Sets the size of the renderer.
     *
     * @param {number} width - The width in logical pixels.
     * @param {number} height - The height in logical pixels.
     * @param {boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.
     */
fun setSize(width: Double, height: Double, updateStyle: Boolean = definedExternally): Unit
/**
     * Defines a manual sort function for the opaque render list.
     * Pass `null` to use the default sort.
     *
     * @param {Function} method - The sort function.
     */
fun setOpaqueSort(method: ((a: RenderItem, b: RenderItem) -> Double)?): Unit
/**
     * Defines a manual sort function for the transparent render list.
     * Pass `null` to use the default sort.
     *
     * @param {Function} method - The sort function.
     */
fun setTransparentSort(method: ((a: RenderItem, b: RenderItem) -> Double)?): Unit
/**
     * Returns the scissor rectangle.
     *
     * @param {Vector4} target - The method writes the result in this target object.
     * @return {Vector4} The scissor rectangle.
     */
fun getScissor(target: Vector4): Vector4
/**
     * Defines the scissor rectangle.
     *
     * @param {number | Vector4} x - The horizontal coordinate for the upper left corner of the box in logical pixel unit.
     * Instead of passing four arguments, the method also works with a single four-dimensional vector.
     * @param {number} y - The vertical coordinate for the upper left corner of the box in logical pixel unit.
     * @param {number} width - The width of the scissor box in logical pixel unit.
     * @param {number} height - The height of the scissor box in logical pixel unit.
     */
fun setScissor(x: Vector4): Unit
fun setScissor(x: Double, y: Double, width: Double, height: Double): Unit
/**
     * Returns the scissor test value.
     *
     * @return {boolean} Whether the scissor test should be enabled or not.
     */
fun getScissorTest(): Boolean
/**
     * Defines the scissor test.
     *
     * @param {boolean} boolean - Whether the scissor test should be enabled or not.
     */
fun setScissorTest(boolean: Boolean): Unit
/**
     * Returns the viewport definition.
     *
     * @param {Vector4} target - The method writes the result in this target object.
     * @return {Vector4} The viewport definition.
     */
fun getViewport(target: Vector4): Vector4
/**
     * Defines the viewport.
     *
     * @param {number | Vector4} x - The horizontal coordinate for the upper left corner of the viewport origin in logical pixel unit.
     * @param {number} y - The vertical coordinate for the upper left corner of the viewport origin  in logical pixel unit.
     * @param {number} width - The width of the viewport in logical pixel unit.
     * @param {number} height - The height of the viewport in logical pixel unit.
     * @param {number} minDepth - The minimum depth value of the viewport. WebGPU only.
     * @param {number} maxDepth - The maximum depth value of the viewport. WebGPU only.
     */
fun setViewport(x: Vector4): Unit
fun setViewport(x: Double, y: Double, width: Double, height: Double, minDepth: Double = definedExternally, maxDepth: Double = definedExternally): Unit
/**
     * Returns the clear color.
     *
     * @param {Color} target - The method writes the result in this target object.
     * @return {Color} The clear color.
     */
fun getClearColor(target: Color4): Color4
/**
     * Defines the clear color and optionally the clear alpha.
     *
     * @param {Color} color - The clear color.
     * @param {number} [alpha=1] - The clear alpha.
     */
fun setClearColor(color: ColorRepresentation, alpha: Double = definedExternally): Unit
/**
     * Returns the clear alpha.
     *
     * @return {number} The clear alpha.
     */
fun getClearAlpha(): Double
/**
     * Defines the clear alpha.
     *
     * @param {number} alpha - The clear alpha.
     */
fun setClearAlpha(alpha: Double): Unit
/**
     * Returns the clear depth.
     *
     * @return {number} The clear depth.
     */
fun getClearDepth(): Double
/**
     * Defines the clear depth.
     *
     * @param {number} depth - The clear depth.
     */
fun setClearDepth(depth: Double): Unit
/**
     * Returns the clear stencil.
     *
     * @return {number} The clear stencil.
     */
fun getClearStencil(): Double
/**
     * Defines the clear stencil.
     *
     * @param {number} stencil - The clear stencil.
     */
fun setClearStencil(stencil: Double): Unit
/**
     * This method performs an occlusion query for the given 3D object.
     * It returns `true` if the given 3D object is fully occluded by other
     * 3D objects in the scene.
     *
     * @param {Object3D} object - The 3D object to test.
     * @return {boolean} Whether the 3D object is fully occluded or not.
     */
fun isOccluded(`object`: Object3D): Boolean?
/**
     * Performs a manual clear operation. This method ignores `autoClear` properties.
     *
     * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
     * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
     * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
     */
fun clear(color: Boolean = definedExternally, depth: Boolean = definedExternally, stencil: Boolean = definedExternally): Unit
/**
     * Performs a manual clear operation of the color buffer. This method ignores `autoClear` properties.
     */
fun clearColor(): Unit
/**
     * Performs a manual clear operation of the depth buffer. This method ignores `autoClear` properties.
     */
fun clearDepth(): Unit
/**
     * Performs a manual clear operation of the stencil buffer. This method ignores `autoClear` properties.
     */
fun clearStencil(): Unit
/**
     * Async version of {@link Renderer#clear}.
     *
     * @async
     * @deprecated
     * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
     * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
     * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
     * @return {Promise} A Promise that resolves when the clear operation has been executed.
     */
fun clearAsync(color: Boolean = definedExternally, depth: Boolean = definedExternally, stencil: Boolean = definedExternally): Promise<js.core.Void>
/**
     * Async version of {@link Renderer#clearColor}.
     *
     * @async
     * @deprecated
     * @return {Promise} A Promise that resolves when the clear operation has been executed.
     */
fun clearColorAsync(): Promise<js.core.Void>
/**
     * Async version of {@link Renderer#clearDepth}.
     *
     * @async
     * @deprecated
     * @return {Promise} A Promise that resolves when the clear operation has been executed.
     */
fun clearDepthAsync(): Promise<js.core.Void>
/**
     * Async version of {@link Renderer#clearStencil}.
     *
     * @async
     * @deprecated
     * @return {Promise} A Promise that resolves when the clear operation has been executed.
     */
fun clearStencilAsync(): Promise<js.core.Void>
/**
     * Returns `true` if a framebuffer target is needed to perform tone mapping or color space conversion.
     * If this is the case, the renderer allocates an internal render target for that purpose.
     */
val needsFrameBufferTarget: Boolean
/**
     * The number of samples used for multi-sample anti-aliasing (MSAA).
     *
     * @type {number}
     * @default 0
     */
val samples: Double
/**
     * The current number of samples used for multi-sample anti-aliasing (MSAA).
     *
     * When rendering to a custom render target, the number of samples of that render target is used.
     * If the renderer needs an internal framebuffer target for tone mapping or color space conversion,
     * the number of samples is set to 0.
     *
     * @type {number}
     */
val currentSamples: Double
/**
     * The current tone mapping of the renderer. When not producing screen output,
     * the tone mapping is always `NoToneMapping`.
     *
     * @type {number}
     */
val currentToneMapping: ToneMapping
/**
     * The current color space of the renderer. When not producing screen output,
     * the color space is always the working color space.
     *
     * @type {string}
     */
val currentColorSpace: String
/**
     * Returns `true` if the rendering settings are set to screen output.
     *
     * @returns {boolean} True if the current render target is the same of output render target or `null`, otherwise false.
     */
val isOutputTarget: Boolean
/**
     * Frees all internal resources of the renderer. Call this method if the renderer
     * is no longer in use by your app.
     */
fun dispose(): Unit
/**
     * Sets the given render target. Calling this method means the renderer does not
     * target the default framebuffer (meaning the canvas) anymore but a custom framebuffer.
     * Use `null` as the first argument to reset the state.
     *
     * @param {?RenderTarget} renderTarget - The render target to set.
     * @param {number} [activeCubeFace=0] - The active cube face.
     * @param {number} [activeMipmapLevel=0] - The active mipmap level.
     */
fun setRenderTarget(renderTarget: RenderTarget?, activeCubeFace: Double = definedExternally, activeMipmapLevel: Double = definedExternally): Unit
/**
     * Returns the current render target.
     *
     * @return {?RenderTarget} The render target. Returns `null` if no render target is set.
     */
fun getRenderTarget(): RenderTarget<Texture<Any?>>?
/**
     * Sets the output render target for the renderer.
     *
     * @param {Object} renderTarget - The render target to set as the output target.
     */
fun setOutputRenderTarget(renderTarget: RenderTarget?): Unit
/**
     * Returns the current output target.
     *
     * @return {?RenderTarget} The current output render target. Returns `null` if no output target is set.
     */
fun getOutputRenderTarget(): RenderTarget<Texture<Any?>>?
/**
     * Sets the canvas target. The canvas target manages the HTML canvas
     * or the offscreen canvas the renderer draws into.
     *
     * @param {CanvasTarget} canvasTarget - The canvas target.
     */
fun setCanvasTarget(canvasTarget: CanvasTarget): Unit
/**
     * Returns the current canvas target.
     *
     * @return {CanvasTarget} The current canvas target.
     */
fun getCanvasTarget(): CanvasTarget
/**
     * Resets the renderer to the initial state before WebXR started.
     *
     * @private
     */
fun _resetXRState(): Unit
/**
     * Callback for {@link Renderer#setRenderObjectFunction}.
     *
     * @callback renderObjectFunction
     * @param {Object3D} object - The 3D object.
     * @param {Scene} scene - The scene the 3D object belongs to.
     * @param {Camera} camera - The camera the object should be rendered with.
     * @param {BufferGeometry} geometry - The object's geometry.
     * @param {Material} material - The object's material.
     * @param {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
     * @param {LightsNode} lightsNode - The current lights node.
     * @param {ClippingContext} clippingContext - The clipping context.
     * @param {?string} [passId=null] - An optional ID for identifying the pass.
     */
/**
     * Sets the given render object function. Calling this method overwrites the default implementation
     * which is {@link Renderer#renderObject}. Defining a custom function can be useful
     * if you want to modify the way objects are rendered. For example you can define things like "every
     * object that has material of a certain type should perform a pre-pass with a special overwrite material".
     * The custom function must always call `renderObject()` in its implementation.
     *
     * Use `null` as the first argument to reset the state.
     *
     * @param {?renderObjectFunction} renderObjectFunction - The render object function.
     */
fun setRenderObjectFunction(renderObjectFunction: ((`object`: Object3D, scene: Scene, camera: Camera, geometry: BufferGeometry, material: Material, group: GeometryGroup, lightsNode: LightsNode) -> Unit)?): Unit
/**
     * Returns the current render object function.
     *
     * @return {?Function} The current render object function. Returns `null` if no function is set.
     */
fun getRenderObjectFunction(): ((`object`: Object3D, scene: Scene, camera: Camera, geometry: BufferGeometry, material: Material, group: GeometryGroup, lightsNode: LightsNode, clippingContext: ClippingContext?, passId: String?) -> Unit)?
/**
     * Execute a single or an array of compute nodes. This method can only be called
     * if the renderer has been initialized.
     *
     * @param {Node|Array<Node>} computeNodes - The compute node(s).
     * @param {number|Array<number>|IndirectStorageBufferAttribute} [dispatchSize=null]
     * - A single number representing count, or
     * - An array [x, y, z] representing dispatch size, or
     * - A IndirectStorageBufferAttribute for indirect dispatch size.
     * @return {Promise|undefined} A Promise that resolve when the compute has finished. Only returned when the renderer has not been initialized.
     */
fun compute(computeNodes: ComputeNode): Promise<js.core.Void>?

/**
     * Execute a single or an array of compute nodes. This method can only be called
     * if the renderer has been initialized.
     *
     * @param {Node|Array<Node>} computeNodes - The compute node(s).
     * @param {number|Array<number>|IndirectStorageBufferAttribute} [dispatchSize=null]
     * - A single number representing count, or
     * - An array [x, y, z] representing dispatch size, or
     * - A IndirectStorageBufferAttribute for indirect dispatch size.
     * @return {Promise|undefined} A Promise that resolve when the compute has finished. Only returned when the renderer has not been initialized.
     */
fun compute(computeNodes: ComputeNode, dispatchSize: js.array.ReadonlyArray<Double>? = definedExternally): Promise<js.core.Void>?

/**
     * Execute a single or an array of compute nodes. This method can only be called
     * if the renderer has been initialized.
     *
     * @param {Node|Array<Node>} computeNodes - The compute node(s).
     * @param {number|Array<number>|IndirectStorageBufferAttribute} [dispatchSize=null]
     * - A single number representing count, or
     * - An array [x, y, z] representing dispatch size, or
     * - A IndirectStorageBufferAttribute for indirect dispatch size.
     * @return {Promise|undefined} A Promise that resolve when the compute has finished. Only returned when the renderer has not been initialized.
     */
fun compute(computeNodes: ComputeNode, dispatchSize: Double? = definedExternally): Promise<js.core.Void>?

/**
     * Execute a single or an array of compute nodes. This method can only be called
     * if the renderer has been initialized.
     *
     * @param {Node|Array<Node>} computeNodes - The compute node(s).
     * @param {number|Array<number>|IndirectStorageBufferAttribute} [dispatchSize=null]
     * - A single number representing count, or
     * - An array [x, y, z] representing dispatch size, or
     * - A IndirectStorageBufferAttribute for indirect dispatch size.
     * @return {Promise|undefined} A Promise that resolve when the compute has finished. Only returned when the renderer has not been initialized.
     */
fun compute(computeNodes: ComputeNode, dispatchSize: IndirectStorageBufferAttribute? = definedExternally): Promise<js.core.Void>?

/**
     * Execute a single or an array of compute nodes. This method can only be called
     * if the renderer has been initialized.
     *
     * @param {Node|Array<Node>} computeNodes - The compute node(s).
     * @param {number|Array<number>|IndirectStorageBufferAttribute} [dispatchSize=null]
     * - A single number representing count, or
     * - An array [x, y, z] representing dispatch size, or
     * - A IndirectStorageBufferAttribute for indirect dispatch size.
     * @return {Promise|undefined} A Promise that resolve when the compute has finished. Only returned when the renderer has not been initialized.
     */
fun compute(computeNodes: js.array.ReadonlyArray<ComputeNode>): Promise<js.core.Void>?

/**
     * Execute a single or an array of compute nodes. This method can only be called
     * if the renderer has been initialized.
     *
     * @param {Node|Array<Node>} computeNodes - The compute node(s).
     * @param {number|Array<number>|IndirectStorageBufferAttribute} [dispatchSize=null]
     * - A single number representing count, or
     * - An array [x, y, z] representing dispatch size, or
     * - A IndirectStorageBufferAttribute for indirect dispatch size.
     * @return {Promise|undefined} A Promise that resolve when the compute has finished. Only returned when the renderer has not been initialized.
     */
fun compute(computeNodes: js.array.ReadonlyArray<ComputeNode>, dispatchSize: js.array.ReadonlyArray<Double>? = definedExternally): Promise<js.core.Void>?

/**
     * Execute a single or an array of compute nodes. This method can only be called
     * if the renderer has been initialized.
     *
     * @param {Node|Array<Node>} computeNodes - The compute node(s).
     * @param {number|Array<number>|IndirectStorageBufferAttribute} [dispatchSize=null]
     * - A single number representing count, or
     * - An array [x, y, z] representing dispatch size, or
     * - A IndirectStorageBufferAttribute for indirect dispatch size.
     * @return {Promise|undefined} A Promise that resolve when the compute has finished. Only returned when the renderer has not been initialized.
     */
fun compute(computeNodes: js.array.ReadonlyArray<ComputeNode>, dispatchSize: Double? = definedExternally): Promise<js.core.Void>?

/**
     * Execute a single or an array of compute nodes. This method can only be called
     * if the renderer has been initialized.
     *
     * @param {Node|Array<Node>} computeNodes - The compute node(s).
     * @param {number|Array<number>|IndirectStorageBufferAttribute} [dispatchSize=null]
     * - A single number representing count, or
     * - An array [x, y, z] representing dispatch size, or
     * - A IndirectStorageBufferAttribute for indirect dispatch size.
     * @return {Promise|undefined} A Promise that resolve when the compute has finished. Only returned when the renderer has not been initialized.
     */
fun compute(computeNodes: js.array.ReadonlyArray<ComputeNode>, dispatchSize: IndirectStorageBufferAttribute? = definedExternally): Promise<js.core.Void>?
/**
     * Execute a single or an array of compute nodes.
     *
     * @async
     * @param {Node|Array<Node>} computeNodes - The compute node(s).
     * @param {number|Array<number>|IndirectStorageBufferAttribute} [dispatchSize=null]
     * - A single number representing count, or
     * - An array [x, y, z] representing dispatch size, or
     * - A IndirectStorageBufferAttribute for indirect dispatch size.
     * @return {Promise} A Promise that resolve when the compute has finished.
     */
fun computeAsync(computeNodes: ComputeNode): Promise<js.core.Void>

/**
     * Execute a single or an array of compute nodes.
     *
     * @async
     * @param {Node|Array<Node>} computeNodes - The compute node(s).
     * @param {number|Array<number>|IndirectStorageBufferAttribute} [dispatchSize=null]
     * - A single number representing count, or
     * - An array [x, y, z] representing dispatch size, or
     * - A IndirectStorageBufferAttribute for indirect dispatch size.
     * @return {Promise} A Promise that resolve when the compute has finished.
     */
fun computeAsync(computeNodes: ComputeNode, dispatchSize: js.array.ReadonlyArray<Double>? = definedExternally): Promise<js.core.Void>

/**
     * Execute a single or an array of compute nodes.
     *
     * @async
     * @param {Node|Array<Node>} computeNodes - The compute node(s).
     * @param {number|Array<number>|IndirectStorageBufferAttribute} [dispatchSize=null]
     * - A single number representing count, or
     * - An array [x, y, z] representing dispatch size, or
     * - A IndirectStorageBufferAttribute for indirect dispatch size.
     * @return {Promise} A Promise that resolve when the compute has finished.
     */
fun computeAsync(computeNodes: ComputeNode, dispatchSize: Double? = definedExternally): Promise<js.core.Void>

/**
     * Execute a single or an array of compute nodes.
     *
     * @async
     * @param {Node|Array<Node>} computeNodes - The compute node(s).
     * @param {number|Array<number>|IndirectStorageBufferAttribute} [dispatchSize=null]
     * - A single number representing count, or
     * - An array [x, y, z] representing dispatch size, or
     * - A IndirectStorageBufferAttribute for indirect dispatch size.
     * @return {Promise} A Promise that resolve when the compute has finished.
     */
fun computeAsync(computeNodes: ComputeNode, dispatchSize: IndirectStorageBufferAttribute? = definedExternally): Promise<js.core.Void>

/**
     * Execute a single or an array of compute nodes.
     *
     * @async
     * @param {Node|Array<Node>} computeNodes - The compute node(s).
     * @param {number|Array<number>|IndirectStorageBufferAttribute} [dispatchSize=null]
     * - A single number representing count, or
     * - An array [x, y, z] representing dispatch size, or
     * - A IndirectStorageBufferAttribute for indirect dispatch size.
     * @return {Promise} A Promise that resolve when the compute has finished.
     */
fun computeAsync(computeNodes: js.array.ReadonlyArray<ComputeNode>): Promise<js.core.Void>

/**
     * Execute a single or an array of compute nodes.
     *
     * @async
     * @param {Node|Array<Node>} computeNodes - The compute node(s).
     * @param {number|Array<number>|IndirectStorageBufferAttribute} [dispatchSize=null]
     * - A single number representing count, or
     * - An array [x, y, z] representing dispatch size, or
     * - A IndirectStorageBufferAttribute for indirect dispatch size.
     * @return {Promise} A Promise that resolve when the compute has finished.
     */
fun computeAsync(computeNodes: js.array.ReadonlyArray<ComputeNode>, dispatchSize: js.array.ReadonlyArray<Double>? = definedExternally): Promise<js.core.Void>

/**
     * Execute a single or an array of compute nodes.
     *
     * @async
     * @param {Node|Array<Node>} computeNodes - The compute node(s).
     * @param {number|Array<number>|IndirectStorageBufferAttribute} [dispatchSize=null]
     * - A single number representing count, or
     * - An array [x, y, z] representing dispatch size, or
     * - A IndirectStorageBufferAttribute for indirect dispatch size.
     * @return {Promise} A Promise that resolve when the compute has finished.
     */
fun computeAsync(computeNodes: js.array.ReadonlyArray<ComputeNode>, dispatchSize: Double? = definedExternally): Promise<js.core.Void>

/**
     * Execute a single or an array of compute nodes.
     *
     * @async
     * @param {Node|Array<Node>} computeNodes - The compute node(s).
     * @param {number|Array<number>|IndirectStorageBufferAttribute} [dispatchSize=null]
     * - A single number representing count, or
     * - An array [x, y, z] representing dispatch size, or
     * - A IndirectStorageBufferAttribute for indirect dispatch size.
     * @return {Promise} A Promise that resolve when the compute has finished.
     */
fun computeAsync(computeNodes: js.array.ReadonlyArray<ComputeNode>, dispatchSize: IndirectStorageBufferAttribute? = definedExternally): Promise<js.core.Void>
/**
     * Checks if the given feature is supported by the selected backend.
     *
     * @async
     * @deprecated
     * @param {string} name - The feature's name.
     * @return {Promise<boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.
     */
fun hasFeatureAsync(name: String): Promise<js.core.Void>
fun resolveTimestampsAsync(type: TimestampQuery = definedExternally): Promise<Double?>
/**
     * Checks if the given feature is supported by the selected backend. If the
     * renderer has not been initialized, this method always returns `false`.
     *
     * @param {string} name - The feature's name.
     * @return {boolean} Whether the feature is supported or not.
     */
fun hasFeature(name: String): Unit
/**
     * Returns `true` when the renderer has been initialized.
     *
     * @return {boolean} Whether the renderer has been initialized or not.
     */
fun hasInitialized(): Boolean
/**
     * Initializes the given textures. Useful for preloading a texture rather than waiting until first render
     * (which can cause noticeable lags due to decode and GPU upload overhead).
     *
     * @async
     * @deprecated
     * @param {Texture} texture - The texture.
     * @return {Promise} A Promise that resolves when the texture has been initialized.
     */
fun initTextureAsync(texture: Texture): Promise<js.core.Void>
/**
     * Initializes the given texture. Useful for preloading a texture rather than waiting until first render
     * (which can cause noticeable lags due to decode and GPU upload overhead).
     *
     * This method can only be used if the renderer has been initialized.
     *
     * @param {Texture} texture - The texture.
     */
fun initTexture(texture: Texture): Unit
/**
     * Copies the current bound framebuffer into the given texture.
     *
     * @param {FramebufferTexture} framebufferTexture - The texture.
     * @param {?(Vector2|Vector4)} [rectangle=null] - A two or four dimensional vector that defines the rectangular portion of the framebuffer that should be copied.
     */
fun copyFramebufferToTexture(framebufferTexture: FramebufferTexture, rectangle: Rectangle? = definedExternally): Unit
/**
     * Copies data of the given source texture into a destination texture.
     *
     * @param {Texture} srcTexture - The source texture.
     * @param {Texture} dstTexture - The destination texture.
     * @param {Box2|Box3} [srcRegion=null] - A bounding box which describes the source region. Can be two or three-dimensional.
     * @param {Vector2|Vector3} [dstPosition=null] - A vector that represents the origin of the destination region. Can be two or three-dimensional.
     * @param {number} [srcLevel=0] - The source mip level to copy from.
     * @param {number} [dstLevel=0] - The destination mip level to copy to.
     */
fun copyTextureToTexture(srcTexture: Texture, dstTexture: Texture): Unit

/**
     * Copies data of the given source texture into a destination texture.
     *
     * @param {Texture} srcTexture - The source texture.
     * @param {Texture} dstTexture - The destination texture.
     * @param {Box2|Box3} [srcRegion=null] - A bounding box which describes the source region. Can be two or three-dimensional.
     * @param {Vector2|Vector3} [dstPosition=null] - A vector that represents the origin of the destination region. Can be two or three-dimensional.
     * @param {number} [srcLevel=0] - The source mip level to copy from.
     * @param {number} [dstLevel=0] - The destination mip level to copy to.
     */
fun copyTextureToTexture(srcTexture: Texture, dstTexture: Texture, srcRegion: Box2? = definedExternally, dstPosition: Vector2? = definedExternally, srcLevel: Double = definedExternally, dstLevel: Double = definedExternally): Unit

/**
     * Copies data of the given source texture into a destination texture.
     *
     * @param {Texture} srcTexture - The source texture.
     * @param {Texture} dstTexture - The destination texture.
     * @param {Box2|Box3} [srcRegion=null] - A bounding box which describes the source region. Can be two or three-dimensional.
     * @param {Vector2|Vector3} [dstPosition=null] - A vector that represents the origin of the destination region. Can be two or three-dimensional.
     * @param {number} [srcLevel=0] - The source mip level to copy from.
     * @param {number} [dstLevel=0] - The destination mip level to copy to.
     */
fun copyTextureToTexture(srcTexture: Texture, dstTexture: Texture, srcRegion: Box2? = definedExternally, dstPosition: Vector3? = definedExternally, srcLevel: Double = definedExternally, dstLevel: Double = definedExternally): Unit

/**
     * Copies data of the given source texture into a destination texture.
     *
     * @param {Texture} srcTexture - The source texture.
     * @param {Texture} dstTexture - The destination texture.
     * @param {Box2|Box3} [srcRegion=null] - A bounding box which describes the source region. Can be two or three-dimensional.
     * @param {Vector2|Vector3} [dstPosition=null] - A vector that represents the origin of the destination region. Can be two or three-dimensional.
     * @param {number} [srcLevel=0] - The source mip level to copy from.
     * @param {number} [dstLevel=0] - The destination mip level to copy to.
     */
fun copyTextureToTexture(srcTexture: Texture, dstTexture: Texture, srcRegion: Box3? = definedExternally, dstPosition: Vector2? = definedExternally, srcLevel: Double = definedExternally, dstLevel: Double = definedExternally): Unit

/**
     * Copies data of the given source texture into a destination texture.
     *
     * @param {Texture} srcTexture - The source texture.
     * @param {Texture} dstTexture - The destination texture.
     * @param {Box2|Box3} [srcRegion=null] - A bounding box which describes the source region. Can be two or three-dimensional.
     * @param {Vector2|Vector3} [dstPosition=null] - A vector that represents the origin of the destination region. Can be two or three-dimensional.
     * @param {number} [srcLevel=0] - The source mip level to copy from.
     * @param {number} [dstLevel=0] - The destination mip level to copy to.
     */
fun copyTextureToTexture(srcTexture: Texture, dstTexture: Texture, srcRegion: Box3? = definedExternally, dstPosition: Vector3? = definedExternally, srcLevel: Double = definedExternally, dstLevel: Double = definedExternally): Unit
/**
     * Reads pixel data from the given render target.
     *
     * @async
     * @param {RenderTarget} renderTarget - The render target to read from.
     * @param {number} x - The `x` coordinate of the copy region's origin.
     * @param {number} y - The `y` coordinate of the copy region's origin.
     * @param {number} width - The width of the copy region.
     * @param {number} height - The height of the copy region.
     * @param {number} [textureIndex=0] - The texture index of a MRT render target.
     * @param {number} [faceIndex=0] - The active cube face index.
     * @return {Promise<TypedArray>} A Promise that resolves when the read has been finished. The resolve provides the read data as a typed array.
     */
fun readRenderTargetPixelsAsync(renderTarget: RenderTarget, x: Double, y: Double, width: Double, height: Double, textureIndex: Double = definedExternally, faceIndex: Double = definedExternally): Promise</* import("../../core/BufferAttribute.js") */ TypedArray>
/**
     * Analyzes the given 3D object's hierarchy and builds render lists from the
     * processed hierarchy.
     *
     * @private
     * @param {Object3D} object - The 3D object to process (usually a scene).
     * @param {Camera} camera - The camera the object is rendered with.
     * @param {number} groupOrder - The group order is derived from the `renderOrder` of groups and is used to group 3D objects within groups.
     * @param {RenderList} renderList - The current render list.
     * @param {ClippingContext} clippingContext - The current clipping context.
     */
fun _projectObject(`object`: Object3D, camera: Camera, groupOrder: Double, renderList: RenderList, clippingContext: ClippingContext?): Unit
/**
     * Renders the given render bundles.
     *
     * @private
     * @param {Array<Object>} bundles - Array with render bundle data.
     * @param {Scene} sceneRef - The scene the render bundles belong to.
     * @param {LightsNode} lightsNode - The current lights node.
     */
fun _renderBundles(bundles: js.array.ReadonlyArray<Bundle>, sceneRef: Scene, lightsNode: LightsNode): Unit
/**
     * Renders the transparent objects from the given render lists.
     *
     * @private
     * @param {Array<Object>} renderList - The transparent render list.
     * @param {Array<Object>} doublePassList - The list of transparent objects which require a double pass (e.g. because of transmission).
     * @param {Camera} camera - The camera the render list should be rendered with.
     * @param {Scene} scene - The scene the render list belongs to.
     * @param {LightsNode} lightsNode - The current lights node.
     */
fun _renderTransparents(renderList: js.array.ReadonlyArray<RenderItem>, doublePassList: js.array.ReadonlyArray<RenderItem>, camera: Camera, scene: Scene, lightsNode: LightsNode): Unit
/**
     * Renders the objects from the given render list.
     *
     * @private
     * @param {Array<Object>} renderList - The render list.
     * @param {Camera} camera - The camera the render list should be rendered with.
     * @param {Scene} scene - The scene the render list belongs to.
     * @param {LightsNode} lightsNode - The current lights node.
     * @param {?string} [passId=null] - An optional ID for identifying the pass.
     */
fun _renderObjects(renderList: js.array.ReadonlyArray<RenderItem>, camera: Camera, scene: Scene, lightsNode: LightsNode, passId: String? = definedExternally): Unit
/**
     * Retrieves shadow nodes for the given material. This is used to setup shadow passes.
     * The result is cached per material and updated when the material's version changes.
     *
     * @private
     * @param {Material} material
     * @returns {Object} - The shadow nodes for the material.
     */
fun _getShadowNodes(material: Material): Any?
/**
     * This method represents the default render object function that manages the render lifecycle
     * of the object.
     *
     * @param {Object3D} object - The 3D object.
     * @param {Scene} scene - The scene the 3D object belongs to.
     * @param {Camera} camera - The camera the object should be rendered with.
     * @param {BufferGeometry} geometry - The object's geometry.
     * @param {Material} material - The object's material.
     * @param {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
     * @param {LightsNode} lightsNode - The current lights node.
     * @param {?ClippingContext} clippingContext - The clipping context.
     * @param {?string} [passId=null] - An optional ID for identifying the pass.
     */
fun renderObject(`object`: Object3D, scene: Scene, camera: Camera, geometry: BufferGeometry, material: Material, group: GeometryGroup, lightsNode: LightsNode, clippingContext: ClippingContext? = definedExternally, passId: String? = definedExternally): Unit
/**
     * This method represents the default `_handleObjectFunction` implementation which creates
     * a render object from the given data and performs the draw command with the selected backend.
     *
     * @private
     * @param {Object3D} object - The 3D object.
     * @param {Material} material - The object's material.
     * @param {Scene} scene - The scene the 3D object belongs to.
     * @param {Camera} camera - The camera the object should be rendered with.
     * @param {LightsNode} lightsNode - The current lights node.
     * @param {?{start: number, count: number}} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
     * @param {ClippingContext} clippingContext - The clipping context.
     * @param {string} [passId] - An optional ID for identifying the pass.
     */
fun _renderObjectDirect(`object`: Object3D, material: Material, scene: Scene, camera: Camera, lightsNode: LightsNode, group: GeometryGroup, clippingContext: ClippingContext?, passId: String = definedExternally): Unit
/**
     * A different implementation for `_handleObjectFunction` which only makes sure the object is ready for rendering.
     * Used in `compileAsync()`.
     *
     * @private
     * @param {Object3D} object - The 3D object.
     * @param {Material} material - The object's material.
     * @param {Scene} scene - The scene the 3D object belongs to.
     * @param {Camera} camera - The camera the object should be rendered with.
     * @param {LightsNode} lightsNode - The current lights node.
     * @param {?{start: number, count: number}} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
     * @param {ClippingContext} clippingContext - The clipping context.
     * @param {string} [passId] - An optional ID for identifying the pass.
     */
fun _createObjectPipeline(`object`: Object3D, material: Material, scene: Scene, camera: Camera, lightsNode: LightsNode, group: Group, clippingContext: ClippingContext?, passId: String = definedExternally): Unit
/**
     * Callback when the canvas has been resized.
     *
     * @private
     */
fun _onCanvasTargetResize(): Unit
/**
     * Alias for `compileAsync()`.
     *
     * @method
     * @param {Object3D} scene - The scene or 3D object to precompile.
     * @param {Camera} camera - The camera that is used to render the scene.
     * @param {Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.
     * @return {function(Object3D, Camera, ?Scene): Promise|undefined} A Promise that resolves when the compile has been finished.
     */
val compile: (scene: Object3D, camera: Camera, targetScene: Scene? /* use undefined for default */) -> Promise<js.core.Void>
}

/**
 * Animation loop parameter of `renderer.setAnimationLoop()`.
 *
 * @callback onAnimationCallback
 * @param {DOMHighResTimeStamp} time - A timestamp indicating the end time of the previous frame's rendering.
 * @param {XRFrame} [frame] - A reference to the current XR frame. Only relevant when using XR rendering.
 */
/* export default Renderer; */
external interface RendererShadowMap {
var enabled: Boolean
var type: ShadowMapType?
}

external interface Temp109 {
var fragmentShader: String?
var vertexShader: String?
}

external interface RendererDebug {
var checkShaderErrors: Boolean
var onShaderError: ((gl: WebGL2RenderingContext, programGPU: WebGLProgram, glVertexShader: WebGLShader, glFragmentShader: WebGLShader) -> Unit)?
var getShaderAsync: (scene: Scene, camera: Camera, `object`: Object3D) -> Promise<Temp109>
}

sealed external interface DeviceLostInfoApi {
companion object {
@seskar.js.JsValue("WebGL")
val WebGL: DeviceLostInfoApi
@seskar.js.JsValue("WebGPU")
val WebGPU: DeviceLostInfoApi
}
}