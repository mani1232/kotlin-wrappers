// Generated by Karakum - do not modify it manually!

@file:JsModule("threethree")

package three.src.renderers.common

// unhandled import: ArrayCamera from "../../cameras/ArrayCamera.js"
// unhandled import: PerspectiveCamera from "../../cameras/PerspectiveCamera.js"
// unhandled import: EventDispatcher from "../../core/EventDispatcher.js"
// unhandled import: RenderTarget from "../../core/RenderTarget.js"
// unhandled import: CylinderGeometry from "../../geometries/CylinderGeometry.js"
// unhandled import: PlaneGeometry from "../../geometries/PlaneGeometry.js"
// unhandled import: Material from "../../materials/Material.js"
// unhandled import: MeshBasicMaterial from "../../materials/MeshBasicMaterial.js"
// unhandled import: Quaternion from "../../math/Quaternion.js"
// unhandled import: Vector2 from "../../math/Vector2.js"
// unhandled import: Vector3 from "../../math/Vector3.js"
// unhandled import: Mesh from "../../objects/Mesh.js"
// unhandled import: WebXRController from "../webxr/WebXRController.js"
// unhandled import: AnimationContext from "./Animation.js"
// unhandled import: default as QuadMesh from "./QuadMesh.js"
// unhandled import: default as Renderer from "./Renderer.js"
// unhandled import: XRRenderTarget from "./XRRenderTarget.js"



































external interface XRManagerEventMap {
var sessionstart: Any
var sessionend: Any
var planesdetected: XRManagerEventMapPlanesdetected
}

external interface XRQuadLayerObject {
var type: String /* "quad" */
var width: Double
var height: Double
var translation: Vector3
var quaternion: Quaternion
var pixelwidth: Double
var pixelheight: Double
var plane: Mesh
var material: Material
var rendercall: () -> Unit
var renderTarget: XRRenderTarget
var xrlayer: XRLayer?
}

external interface XRCylinderLayerObject {
var type: String /* "cylinder" */
var radius: Double
var centralAngle: Double
var aspectratio: Double
var translation: Vector3
var quaternion: Quaternion
var pixelwidth: Double
var pixelheight: Double
var plane: Mesh
var material: Material
var rendercall: () -> Unit
var renderTarget: XRRenderTarget
var xrlayer: XRLayer?
}

typealias XRLayerObject = Any /* XRQuadLayerObject | XRCylinderLayerObject */

external interface LayerAttributes {
var stencil: Boolean?
}

/**
 * The XR manager is built on top of the WebXR Device API to
 * manage XR sessions with `WebGPURenderer`.
 *
 * XR is currently only supported with a WebGL 2 backend.
 *
 * @augments EventDispatcher
 */
external class XRManager : EventDispatcher<XRManagerEventMap> {
/**
     * Constructs a new XR manager.
     *
     * @param {Renderer} renderer - The renderer.
     * @param {boolean} [multiview=false] - Enables multiview if the device supports it.
     */
constructor (renderer: Renderer, multiview: Boolean = definedExternally)
var enabled: Boolean
var isPresenting: Boolean
var cameraAutoUpdate: Boolean
var _renderer: Renderer
var _cameraL: PerspectiveCamera
var _cameraR: PerspectiveCamera
var _cameras: js.array.ReadonlyArray<PerspectiveCamera>
var _cameraXR: ArrayCamera
var _currentDepthNear: Double?
var _currentDepthFar: Double?
var _controllers: js.array.ReadonlyArray<WebXRController>
var _controllerInputSources: js.array.ReadonlyArray<(XRInputSource?)>
var _xrRenderTarget: XRRenderTarget?
var _layers: js.array.ReadonlyArray<XRLayerObject>
var _sessionUsesLayers: Boolean
var _supportsLayers: Boolean
var _supportsGlBinding: Boolean
var _frameBufferTargets: WeakMap<XRRenderTarget, Temp108>?
var _createXRLayer: (layer: XRLayerObject) -> XRLayer
var _gl: WebGL2RenderingContext?
var _currentAnimationContext: AnimationContext?
var _currentAnimationLoop: ((time: DOMHighResTimeStamp, frame: XRFrame? /* use undefined for default */) -> Unit)?
var _currentPixelRatio: Double?
var _currentSize: Vector2
var _onSessionEvent: (event: XRInputSourceEvent) -> Unit
var _onSessionEnd: () -> Unit
var _onInputSourcesChange: (event: XRInputSourcesChangeEvent) -> Unit
var _onAnimationFrame: (time: DOMHighResTimeStamp, frame: XRFrame? /* use undefined for default */) -> Unit
var _referenceSpace: XRReferenceSpace?
var _referenceSpaceType: XRReferenceSpaceType
var _customReferenceSpace: XRReferenceSpace?
var _framebufferScaleFactor: Double
var _foveation: Double
var _session: XRSession?
var _glBaseLayer: XRWebGLLayer?
var _glBinding: XRWebGLBinding?
var _glProjLayer: XRProjectionLayer?
var _xrFrame: XRFrame?
var _useLayers: Boolean
var _useMultiviewIfPossible: Boolean
var _useMultiview: Boolean
/**
     * Returns an instance of `THREE.Group` that represents the transformation
     * of a XR controller in target ray space. The requested controller is defined
     * by the given index.
     *
     * @param {number} index - The index of the XR controller.
     * @return {Group} A group that represents the controller's transformation.
     */
fun getController(index: Double): /* import("../webxr/WebXRController.js") */ XRTargetRaySpace
/**
     * Returns an instance of `THREE.Group` that represents the transformation
     * of a XR controller in grip space. The requested controller is defined
     * by the given index.
     *
     * @param {number} index - The index of the XR controller.
     * @return {Group} A group that represents the controller's transformation.
     */
fun getControllerGrip(index: Double): /* import("../webxr/WebXRController.js") */ XRGripSpace
/**
     * Returns an instance of `THREE.Group` that represents the transformation
     * of a XR controller in hand space. The requested controller is defined
     * by the given index.
     *
     * @param {number} index - The index of the XR controller.
     * @return {Group} A group that represents the controller's transformation.
     */
fun getHand(index: Double): /* import("../webxr/WebXRController.js") */ XRHandSpace
/**
     * Returns the foveation value.
     *
     * @return {number|undefined} The foveation value. Returns `undefined` if no base or projection layer is defined.
     */
fun getFoveation(): Double?
/**
     * Sets the foveation value.
     *
     * @param {number} foveation - A number in the range `[0,1]` where `0` means no foveation (full resolution)
     * and `1` means maximum foveation (the edges render at lower resolution).
     */
fun setFoveation(foveation: Double): Unit
/**
     * Returns the framebuffer scale factor.
     *
     * @return {number} The framebuffer scale factor.
     */
fun getFramebufferScaleFactor(): Double
/**
     * Sets the framebuffer scale factor.
     *
     * This method can not be used during a XR session.
     *
     * @param {number} factor - The framebuffer scale factor.
     */
fun setFramebufferScaleFactor(factor: Double): Unit
/**
     * Returns the reference space type.
     *
     * @return {XRReferenceSpaceType} The reference space type.
     */
fun getReferenceSpaceType(): XRReferenceSpaceType
/**
     * Sets the reference space type.
     *
     * This method can not be used during a XR session.
     *
     * @param {XRReferenceSpaceType} type - The reference space type.
     */
fun setReferenceSpaceType(type: XRReferenceSpaceType): Unit
/**
     * Returns the XR reference space.
     *
     * @return {XRReferenceSpace} The XR reference space.
     */
fun getReferenceSpace(): XRReferenceSpace?
/**
     * Sets a custom XR reference space.
     *
     * @param {XRReferenceSpace} space - The XR reference space.
     */
fun setReferenceSpace(space: XRReferenceSpace): Unit
/**
     * Returns the XR camera.
     *
     * @return {ArrayCamera} The XR camera.
     */
fun getCamera(): ArrayCamera
/**
     * Returns the environment blend mode from the current XR session.
     *
     * @return {'opaque'|'additive'|'alpha-blend'|undefined} The environment blend mode. Returns `undefined` when used outside of a XR session.
     */
fun getEnvironmentBlendMode(): XREnvironmentBlendMode?
/**
     * Returns the current XR binding.
     *
     * Creates a new binding if needed and the browser is
     * capable of doing so.
     *
     * @return {?XRWebGLBinding} The XR binding. Returns `null` if one cannot be created.
     */
fun getBinding(): XRWebGLBinding?
/**
     * Returns the current XR frame.
     *
     * @return {?XRFrame} The XR frame. Returns `null` when used outside a XR session.
     */
fun getFrame(): XRFrame?
/**
     * Returns `true` if the engine renders to a multiview target.
     *
     * @return {boolean} Whether the engine renders to a multiview render target or not.
     */
fun useMultiview(): Boolean
/**
     * This method can be used in XR applications to create a quadratic layer that presents a separate
     * rendered scene.
     *
     * @param {number} width - The width of the layer plane in world units.
     * @param {number} height - The height of the layer plane in world units.
     * @param {Vector3} translation - The position/translation of the layer plane in world units.
     * @param {Quaternion} quaternion - The orientation of the layer plane expressed as a quaternion.
     * @param {number} pixelwidth - The width of the layer's render target in pixels.
     * @param {number} pixelheight - The height of the layer's render target in pixels.
     * @param {Function} rendercall - A callback function that renders the layer. Similar to code in
     * the default animation loop, this method can be used to update/transform 3D object in the layer's scene.
     * @param {Object} [attributes={}] - Allows to configure the layer's render target.
     * @return {Mesh} A mesh representing the quadratic XR layer. This mesh should be added to the XR scene.
     */
fun createQuadLayer(width: Double, height: Double, translation: Vector3, quaternion: Quaternion, pixelwidth: Double, pixelheight: Double, rendercall: () -> Unit, attributes: LayerAttributes = definedExternally): Mesh<PlaneGeometry, MeshBasicMaterial, /* import("../../core/Object3D.js") */ Object3DEventMap>
/**
     * This method can be used in XR applications to create a cylindrical layer that presents a separate
     * rendered scene.
     *
     * @param {number} radius - The radius of the cylinder in world units.
     * @param {number} centralAngle - The central angle of the cylinder in radians.
     * @param {number} aspectratio - The aspect ratio.
     * @param {Vector3} translation - The position/translation of the layer plane in world units.
     * @param {Quaternion} quaternion - The orientation of the layer plane expressed as a quaternion.
     * @param {number} pixelwidth - The width of the layer's render target in pixels.
     * @param {number} pixelheight - The height of the layer's render target in pixels.
     * @param {Function} rendercall - A callback function that renders the layer. Similar to code in
     * the default animation loop, this method can be used to update/transform 3D object in the layer's scene.
     * @param {Object} [attributes={}] - Allows to configure the layer's render target.
     * @return {Mesh} A mesh representing the cylindrical XR layer. This mesh should be added to the XR scene.
     */
fun createCylinderLayer(radius: Double, centralAngle: Double, aspectratio: Double, translation: Vector3, quaternion: Quaternion, pixelwidth: Double, pixelheight: Double, rendercall: () -> Unit, attributes: LayerAttributes = definedExternally): Mesh<CylinderGeometry, MeshBasicMaterial, /* import("../../core/Object3D.js") */ Object3DEventMap>
/**
     * Renders the XR layers that have been previously added to the scene.
     *
     * This method is usually called in your animation loop before rendering
     * the actual scene via `renderer.render( scene, camera );`.
     */
fun renderLayers(): Unit
/**
     * Returns the current XR session.
     *
     * @return {?XRSession} The XR session. Returns `null` when used outside a XR session.
     */
fun getSession(): XRSession?
/**
     * After a XR session has been requested usually with one of the `*Button` modules, it
     * is injected into the renderer with this method. This method triggers the start of
     * the actual XR rendering.
     *
     * @async
     * @param {XRSession} session - The XR session to set.
     * @return {Promise} A Promise that resolves when the session has been set.
     */
fun setSession(session: XRSession): Promise<js.core.Void>
/**
     * This method is called by the renderer per frame and updates the XR camera
     * and it sub cameras based on the given camera. The given camera is the "user"
     * camera created on application level and used for non-XR rendering.
     *
     * @param {PerspectiveCamera} camera - The camera.
     */
fun updateCamera(camera: PerspectiveCamera): Unit
/**
     * Returns a WebXR controller for the given controller index.
     *
     * @private
     * @param {number} index - The controller index.
     * @return {WebXRController} The XR controller.
     */
fun _getController(index: Double): WebXRController
}

/* export default XRManager; */
external interface XRManagerEventMapPlanesdetected {
var data: XRFrame
}

external interface Temp108 {
var frameBufferTarget: RenderTarget?
var quad: QuadMesh
}