// Generated by Karakum - do not modify it manually!

@file:JsModule("threethree")

package three.src.renderers.common

// unhandled import: default as NodeAttribute from "../../nodes/core/NodeAttribute.js"



/**
 * Class for representing programmable stages which are vertex,
 * fragment or compute shaders. Unlike fixed-function states (like blending),
 * they represent the programmable part of a pipeline.
 *
 * @private
 */
external class ProgrammableStage {
/**
     * Constructs a new programmable stage.
     *
     * @param {string} code - The shader code.
     * @param {('vertex'|'fragment'|'compute')} stage - The type of stage.
     * @param {string} name - The name of the shader.
     * @param {?Array<Object>} [transforms=null] - The transforms (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
     * @param {?Array<Object>} [attributes=null] - The attributes (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
     */
constructor (code: String, stage: ProgrammableStageStage, name: String, transforms: Nothing? = definedExternally, attributes: js.array.ReadonlyArray<NodeAttribute>? = definedExternally)
var id: Double
var code: String
var stage: ProgrammableStageStage
var name: String
var attributes: js.array.ReadonlyArray<NodeAttribute>?
var usedTimes: Double
}

/* export default ProgrammableStage; */
sealed external interface ProgrammableStageStage {
companion object {
@seskar.js.JsValue("compute")
val compute: ProgrammableStageStage
@seskar.js.JsValue("vertex")
val vertex: ProgrammableStageStage
@seskar.js.JsValue("fragment")
val fragment: ProgrammableStageStage
}
}

sealed external interface ProgrammableStageStage {
companion object {
@seskar.js.JsValue("compute")
val compute: ProgrammableStageStage
@seskar.js.JsValue("vertex")
val vertex: ProgrammableStageStage
@seskar.js.JsValue("fragment")
val fragment: ProgrammableStageStage
}
}