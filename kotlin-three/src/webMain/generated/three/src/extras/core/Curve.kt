// Generated by Karakum - do not modify it manually!

@file:JsModule("threethree")

package three.src.extras.core

// unhandled import: Vector2 from "../../math/Vector2.js"
// unhandled import: Vector3 from "../../math/Vector3.js"





external interface CurveJSON {
var metadata: CurveJSONMetadata
var arcLengthDivisions: Double
var type: String
}

/**
 * An abstract base class for creating a {@link Curve} object that contains methods for interpolation
 * @remarks
 * For an array of Curves see {@link THREE.CurvePath | CurvePath}.
 * @remarks
 * This following curves inherit from THREE.Curve:
 *
 * **2D curves**
 *  - {@link THREE.ArcCurve}
 *  - {@link THREE.CubicBezierCurve}
 *  - {@link THREE.EllipseCurve}
 *  - {@link THREE.LineCurve}
 *  - {@link THREE.QuadraticBezierCurve}
 *  - {@link THREE.SplineCurve}
 *
 * **3D curves**
 *  - {@link THREE.CatmullRomCurve3}
 *  - {@link THREE.CubicBezierCurve3}
 *  - {@link THREE.LineCurve3}
 *  - {@link THREE.QuadraticBezierCurve3}
 *
 * @see {@link https://threejs.org/docs/index.html#api/en/extras/core/Curve | Official Documentation}
 * @see {@link https://github.com/mrdoob/three.js/blob/master/src/extras/core/Curve.js | Source}
 */
external class Curve<TVector : Any /* Vector2 | Vector3 */> {
constructor ()
/**
     * A Read-only _string_ to check if `this` object type.
     * @remarks Sub-classes will update this value.
     * @defaultValue `Curve`
     */
val type: Any /* string | "Curve" */
/**
     * This value determines the amount of divisions when calculating the cumulative segment lengths of a {@link Curve}
     * via {@link .getLengths}.
     * To ensure precision when using methods like {@link .getSpacedPoints}, it is recommended to increase {@link .arcLengthDivisions} if the {@link Curve} is very large.
     * @defaultValue `200`
     * @remarks Expects a `Integer`
     */
var arcLengthDivisions: Double
/**
     * Returns a vector for a given position on the curve.
     * @param t A position on the curve. Must be in the range `[ 0, 1 ]`. Expects a `Float`
     * @param optionalTarget If specified, the result will be copied into this Vector, otherwise a new Vector will be created. Default `new T`.
     */
fun getPoint(t: Double, optionalTarget: TVector = definedExternally): TVector
/**
     * Returns a vector for a given position on the {@link Curve} according to the arc length.
     * @param u A position on the {@link Curve} according to the arc length. Must be in the range `[ 0, 1 ]`. Expects a `Float`
     * @param optionalTarget If specified, the result will be copied into this Vector, otherwise a new Vector will be created. Default `new T`.
     */
fun getPointAt(u: Double, optionalTarget: TVector = definedExternally): TVector
/**
     * Returns a set of divisions `+1` points using {@link .getPoint | getPoint(t)}.
     * @param divisions Number of pieces to divide the {@link Curve} into. Expects a `Integer`. Default `5`
     */
fun getPoints(divisions: Double = definedExternally): js.array.ReadonlyArray<TVector>
/**
     * Returns a set of divisions `+1` equi-spaced points using {@link .getPointAt | getPointAt(u)}.
     * @param divisions Number of pieces to divide the {@link Curve} into. Expects a `Integer`. Default `5`
     */
fun getSpacedPoints(divisions: Double = definedExternally): js.array.ReadonlyArray<TVector>
/**
     * Get total {@link Curve} arc length.
     */
fun getLength(): Double
/**
     * Get list of cumulative segment lengths.
     * @param divisions Expects a `Integer`
     */
fun getLengths(divisions: Double = definedExternally): js.array.ReadonlyArray<Double>
/**
     * Update the cumulative segment distance cache
     * @remarks
     * The method must be called every time {@link Curve} parameters are changed
     * If an updated {@link Curve} is part of a composed {@link Curve} like {@link THREE.CurvePath | CurvePath},
     * {@link .updateArcLengths}() must be called on the composed curve, too.
     */
fun updateArcLengths(): Unit
/**
     * Given u in the range `[ 0, 1 ]`,
     * @remarks
     * `u` and `t` can then be used to give you points which are equidistant from the ends of the curve, using {@link .getPoint}.
     * @param u Expects a `Float`
     * @param distance Expects a `Float`
     * @returns `t` also in the range `[ 0, 1 ]`. Expects a `Float`.
     */
fun getUtoTmapping(u: Double, distance: Double): Double
/**
     * Returns a unit vector tangent at t
     * @remarks
     * If the derived {@link Curve} does not implement its tangent derivation, two points a small delta apart will be used to find its gradient which seems to give a reasonable approximation.
     * @param t A position on the curve. Must be in the range `[ 0, 1 ]`. Expects a `Float`
     * @param optionalTarget If specified, the result will be copied into this Vector, otherwise a new Vector will be created.
     */
fun getTangent(t: Double, optionalTarget: TVector = definedExternally): TVector
/**
     * Returns tangent at a point which is equidistant to the ends of the {@link Curve} from the point given in {@link .getTangent}.
     * @param u A position on the {@link Curve} according to the arc length. Must be in the range `[ 0, 1 ]`. Expects a `Float`
     * @param optionalTarget If specified, the result will be copied into this Vector, otherwise a new Vector will be created.
     */
fun getTangentAt(u: Double, optionalTarget: TVector = definedExternally): TVector
/**
     * Generates the Frenet Frames
     * @remarks
     * Requires a {@link Curve} definition in 3D space
     * Used in geometries like {@link THREE.TubeGeometry | TubeGeometry} or {@link THREE.ExtrudeGeometry | ExtrudeGeometry}.
     * @param segments Expects a `Integer`
     * @param closed
     */
fun computeFrenetFrames(segments: Double, closed: Boolean = definedExternally): CurveComputeFrenetFramesResult
/**
     * Creates a clone of this instance.
     */
fun clone(): Unit /* this */
/**
     * Copies another {@link Curve} object to this instance.
     * @param source
     */
fun copy(source: Curve<TVector>): Unit /* this */
/**
     * Returns a JSON object representation of this instance.
     */
fun toJSON(): CurveJSON
/**
     * Copies the data from the given JSON object to this instance.
     * @param json
     */
fun fromJSON(json: CurveJSON): Unit /* this */
}
external interface CurveJSONMetadata {
var version: Double
var type: String
var generator: String
}

external interface CurveComputeFrenetFramesResult {
var tangents: js.array.ReadonlyArray<Vector3>
var normals: js.array.ReadonlyArray<Vector3>
var binormals: js.array.ReadonlyArray<Vector3>
}