// Generated by Karakum - do not modify it manually!

@file:JsModule("threethree")

package three.src.objects

// unhandled import: BufferAttributeJSON from "./../core/BufferAttribute.js"
// unhandled import: BufferGeometry from "../core/BufferGeometry.js"
// unhandled import: InstancedBufferAttribute from "../core/InstancedBufferAttribute.js"
// unhandled import: JSONMeta from "../core/Object3D.js"
// unhandled import: Object3DEventMap from "../core/Object3D.js"
// unhandled import: Material from "../materials/Material.js"
// unhandled import: Box3 from "../math/Box3.js"
// unhandled import: Color from "../math/Color.js"
// unhandled import: Matrix4 from "../math/Matrix4.js"
// unhandled import: Sphere from "../math/Sphere.js"
// unhandled import: DataTexture from "../textures/DataTexture.js"
// unhandled import: Mesh from "./Mesh.js"
// unhandled import: MeshJSONObject from "./Mesh.js"























external interface InstancedMeshJSONObject : MeshJSONObject {
var count: Double
var instanceMatrix: BufferAttributeJSON
var instanceColor: BufferAttributeJSON?
}

external interface InstancedMeshJSON : MeshJSONObject {
var `object`: InstancedMeshJSONObject
}

external interface InstancedMeshEventMap : Object3DEventMap {
var dispose: Any
}

/**
 * A special version of {@link THREE.Mesh | Mesh} with instanced rendering support
 * @remarks
 * Use {@link InstancedMesh} if you have to render a large number of objects with the same geometry and material(s) but with different world transformations
 * The usage of {@link InstancedMesh} will help you to reduce the number of draw calls and thus improve the overall rendering performance in your application.
 * @see Example: {@link https://threejs.org/examples/#webgl_instancing_dynamic | WebGL / instancing / dynamic}
 * @see Example: {@link https://threejs.org/examples/#webgl_instancing_performance | WebGL / instancing / performance}
 * @see Example: {@link https://threejs.org/examples/#webgl_instancing_scatter | WebGL / instancing / scatter}
 * @see Example: {@link https://threejs.org/examples/#webgl_instancing_raycast | WebGL / instancing / raycast}
 * @see {@link https://threejs.org/docs/index.html#api/en/objects/InstancedMesh | Official Documentation}
 * @see {@link https://github.com/mrdoob/three.js/blob/master/src/objects/InstancedMesh.js | Source}
 */
external class InstancedMesh<TGeometry : BufferGeometry /* default is BufferGeometry */, TMaterial : Any /* Material | Material[] */ /* default is Any /* Material | Material[] */ */, TEventMap : InstancedMeshEventMap /* default is InstancedMeshEventMap */> : Mesh<TGeometry, TMaterial, TEventMap> {
/**
     * Create a new instance of {@link InstancedMesh}
     * @param geometry An instance of {@link BufferGeometry}.
     * @param material A single or an array of {@link Material}. Default is a new {@link MeshBasicMaterial}.
     * @param count The **maximum** number of instances of this Mesh. Expects a `Integer`
     */
constructor (geometry: TGeometry?, material: TMaterial?, count: Double)
/**
     * Read-only flag to check if a given object is of type {@link InstancedMesh}.
     * @remarks This is a _constant_ value
     * @defaultValue `true`
     */
val isInstancedMesh: Boolean /* true */
/**
     * This bounding box encloses all instances of the {@link InstancedMesh},, which can be calculated with {@link computeBoundingBox | .computeBoundingBox()}.
     * @remarks Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are `null`.
     * @defaultValue `null`
     */
var boundingBox: Box3?
/**
     * This bounding sphere encloses all instances of the {@link InstancedMesh}, which can be calculated with {@link computeBoundingSphere | .computeBoundingSphere()}.
     * @remarks bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are `null`.
     * @defaultValue `null`
     */
var boundingSphere: Sphere?
/**
     * The number of instances.
     * @remarks
     * The `count` value passed into the {@link InstancedMesh | constructor} represents the **maximum** number of instances of this mesh.
     * You can change the number of instances at runtime to an integer value in the range `[0, count]`.
     * If you need more instances than the original `count` value, you have to create a new InstancedMesh.
     * Expects a `Integer`
     */
var count: Double
/**
     * Represents the colors of all instances.
     * You have to set {@link InstancedBufferAttribute.needsUpdate | .instanceColor.needsUpdate()} flag to `true` if you modify instanced data via {@link setColorAt | .setColorAt()}.
     * @defaultValue `null`
     */
var instanceColor: InstancedBufferAttribute?
/**
     * Represents the local transformation of all instances.
     * You have to set {@link InstancedBufferAttribute.needsUpdate | .instanceMatrix.needsUpdate()} flag to `true` if you modify instanced data via {@link setMatrixAt | .setMatrixAt()}.
     */
var instanceMatrix: InstancedBufferAttribute
/**
     * Represents the morph target weights of all instances. You have to set its {@link .needsUpdate} flag to true if
     * you modify instanced data via {@link .setMorphAt}.
     */
var morphTexture: DataTexture?
/**
     * Computes the bounding box of the instanced mesh, and updates the {@link .boundingBox} attribute. The bounding box
     * is not computed by the engine; it must be computed by your app. You may need to recompute the bounding box if an
     * instance is transformed via {@link .setMatrixAt()}.
     */
fun computeBoundingBox(): Unit
/**
     * Computes the bounding sphere of the instanced mesh, and updates the {@link .boundingSphere} attribute. The engine
     * automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling. You
     * may need to recompute the bounding sphere if an instance is transformed via [page:.setMatrixAt]().
     */
fun computeBoundingSphere(): Unit
/**
     * Get the color of the defined instance.
     * @param index The index of an instance. Values have to be in the range `[0, count]`. Expects a `Integer`
     * @param color This color object will be set to the color of the defined instance.
     */
fun getColorAt(index: Double, color: Color): Unit
/**
     * Sets the given color to the defined instance
     * @remarks
     * Make sure you set {@link InstancedBufferAttribute.needsUpdate | .instanceColor.needsUpdate()} to `true` after updating all the colors.
     * @param index The index of an instance. Values have to be in the range `[0, count]`. Expects a `Integer`
     * @param color The color of a single instance.
     */
fun setColorAt(index: Double, color: Color): Unit
/**
     * Get the local transformation matrix of the defined instance.
     * @param index The index of an instance Values have to be in the range `[0, count]`. Expects a `Integer`
     * @param matrix This 4x4 matrix will be set to the local transformation matrix of the defined instance.
     */
fun getMatrixAt(index: Double, matrix: Matrix4): Unit
/**
     * Get the morph target weights of the defined instance.
     * @param index The index of an instance. Values have to be in the range [0, count].
     * @param mesh The {@link .morphTargetInfluences} property of this mesh will be filled with the morph target weights of the defined instance.
     */
fun getMorphAt(index: Double, mesh: Mesh): Unit
/**
     * Sets the given local transformation matrix to the defined instance. Make sure you set
     * {@link InstancedBufferAttribute.needsUpdate | .instanceMatrix.needsUpdate()} flag to `true` after updating all
     * the matrices.
     * Negatively scaled matrices are not supported.
     * @param index The index of an instance. Values have to be in the range `[0, count]`. Expects a `Integer`
     * @param matrix A 4x4 matrix representing the local transformation of a single instance.
     */
fun setMatrixAt(index: Double, matrix: Matrix4): Unit
/**
     * Sets the morph target weights to the defined instance. Make sure you set {@link .morphTexture}{@link .needsUpdate}
     * to true after updating all the influences.
     * @param index The index of an instance. Values have to be in the range [0, count].
     * @param mesh A mesh with {@link .morphTargetInfluences} property containing the morph target weights of a single instance.
     */
fun setMorphAt(index: Double, mesh: Mesh): Unit
/**
     * No effect in {@link InstancedMesh}.
     * @ignore
     * @hidden
     */
fun updateMorphTargets(): Unit
/**
     * Frees the GPU-related resources allocated by this instance
     * @remarks
     * Call this method whenever this instance is no longer used in your app.
     */
fun dispose(): Unit /* this */
fun toJSON(meta: JSONMeta = definedExternally): InstancedMeshJSON
}
