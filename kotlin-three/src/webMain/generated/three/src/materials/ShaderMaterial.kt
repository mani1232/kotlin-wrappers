// Generated by Karakum - do not modify it manually!

@file:JsModule("threethree")

package three.src.materials

// unhandled import: GLSLVersion from "../constants.js"
// unhandled import: JSONMeta from "../core/Object3D.js"
// unhandled import: UniformsGroup from "../core/UniformsGroup.js"
// unhandled import: Matrix3Tuple from "../math/Matrix3.js"
// unhandled import: Matrix4Tuple from "../math/Matrix4.js"
// unhandled import: Vector2Tuple from "../math/Vector2.js"
// unhandled import: Vector3Tuple from "../math/Vector3.js"
// unhandled import: Vector4Tuple from "../math/Vector4.js"
// unhandled import: IUniform from "../renderers/shaders/UniformsLib.js"
// unhandled import: MapColorPropertiesToColorRepresentations from "./Material.js"
// unhandled import: Material from "./Material.js"
// unhandled import: MaterialJSON from "./Material.js"
// unhandled import: MaterialProperties from "./Material.js"





















external interface ShaderMaterialProperties : MaterialProperties {
/**
     * Defines custom constants using `#define` directives within the GLSL code
     * for both the vertex shader and the fragment shader; each key/value pair
     * yields another directive.
     * ```js
     * defines: {
     * 	FOO: 15,
     * 	BAR: true
     * }
     * ```
     * Yields the lines:
     * ```
     * #define FOO 15
     * #define BAR true
     * ```
     */
var defines: Record<String, Any?>
/**
     * An object of the form:
     * ```js
     * {
     * 	"uniform1": { value: 1.0 },
     * 	"uniform2": { value: 2 }
     * }
     * ```
     * specifying the uniforms to be passed to the shader code; keys are uniform
     * names, values are definitions of the form
     * ```
     * {
     * 	value: 1.0
     * }
     * ```
     * where `value` is the value of the uniform. Names must match the name of
     * the uniform, as defined in the GLSL code. Note that uniforms are refreshed
     * on every frame, so updating the value of the uniform will immediately
     * update the value available to the GLSL code.
     */
var uniforms: ShaderMaterialPropertiesUniforms
/**
     * An array holding uniforms groups for configuring UBOs.
     */
var uniformsGroups: Array<UniformsGroup>
/**
     * Vertex shader GLSL code. This is the actual code for the shader.
     */
var vertexShader: String
/**
     * Fragment shader GLSL code. This is the actual code for the shader.
     */
var fragmentShader: String
/**
     * Controls line thickness or lines.
     *
     * WebGL and WebGPU ignore this setting and always render line primitives with a
     * width of one pixel.
     *
     * @default 1
     */
var linewidth: Double
/**
     * Renders the geometry as a wireframe.
     *
     * @default false
     */
var wireframe: Boolean
/**
     * Controls the thickness of the wireframe.
     *
     * WebGL and WebGPU ignore this property and always render
     * 1 pixel wide lines.
     *
     * @default 1
     */
var wireframeLinewidth: Double
/**
     * Defines whether the material color is affected by global fog settings; `true`
     * to pass fog uniforms to the shader.
     *
     * Setting this property to `true` requires the definition of fog uniforms. It is
     * recommended to use `UniformsUtils.merge()` to combine the custom shader uniforms
     * with predefined fog uniforms.
     *
     * ```js
     * const material = new ShaderMaterial( {
     *     uniforms: UniformsUtils.merge( [ UniformsLib[ 'fog' ], shaderUniforms ] );
     *     vertexShader: vertexShader,
     *     fragmentShader: fragmentShader,
     *     fog: true
     * } );
     * ```
     *
     * @default false
     */
var fog: Boolean
/**
     * Defines whether this material uses lighting; `true` to pass uniform data
     * related to lighting to this shader.
     *
     * @default false
     */
var lights: Boolean
/**
     * Defines whether this material supports clipping; `true` to let the renderer
     * pass the clippingPlanes uniform.
     *
     * @default false
     */
var clipping: Boolean
/**
     * This object allows to enable certain WebGL 2 extensions.
     *
     * - clipCullDistance: set to `true` to use vertex shader clipping
     * - multiDraw: set to `true` to use vertex shader multi_draw / enable gl_DrawID
     */
var extensions: ShaderMaterialPropertiesExtensions
/**
     * When the rendered geometry doesn't include these attributes but the
     * material does, these default values will be passed to the shaders. This
     * avoids errors when buffer data is missing.
     *
     * - color: [ 1, 1, 1 ]
     * - uv: [ 0, 0 ]
     * - uv1: [ 0, 0 ]
     */
var defaultAttributeValues: ShaderMaterialPropertiesDefaultAttributeValues
/**
     * If set, this calls [gl.bindAttribLocation](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindAttribLocation)
     * to bind a generic vertex index to an attribute variable.
     *
     * @default undefined
     */
var index0AttributeName: String?
/**
     * Can be used to force a uniform update while changing uniforms in
     * {@link Object3D#onBeforeRender}.
     *
     * @default false
     */
var uniformsNeedUpdate: Boolean
/**
     * Defines the GLSL version of custom shader code.
     *
     * @default null
     */
var glslVersion: GLSLVersion?
}

// eslint-disable-next-line @typescript-eslint/no-empty-interface
external interface ShaderMaterialParameters : Partial<MapColorPropertiesToColorRepresentations<ShaderMaterialProperties>> {

}

typealias ShaderMaterialUniformJSON = Any /* {
    type: "t";
    value: string;
} | {
    type: "c";
    value: number;
} | {
    type: "v2";
    value: Vector2Tuple;
} | {
    type: "v3";
    value: Vector3Tuple;
} | {
    type: "v4";
    value: Vector4Tuple;
} | {
    type: "m3";
    value: Matrix3Tuple;
} | {
    type: "m4";
    value: Matrix4Tuple;
} | {
    value: unknown;
} */

external interface ShaderMaterialJSON : MaterialJSON {
var glslVersion: Double?
var uniforms: Record<String, ShaderMaterialUniformJSON>
var defines: Record<String, Any?>?
var vertexShader: String
var fragmentShader: String
var lights: Boolean
var clipping: Boolean
var extensions: Record<String, Boolean>?
}

/**
 * A material rendered with custom shaders. A shader is a small program written in GLSL.
 * that runs on the GPU. You may want to use a custom shader if you need to implement an
 * effect not included with any of the built-in materials.
 *
 * There are the following notes to bear in mind when using a `ShaderMaterial`:
 *
 * - `ShaderMaterial` can only be used with {@link WebGLRenderer}.
 * - Built in attributes and uniforms are passed to the shaders along with your code. If
 * you don't want that, use {@link RawShaderMaterial} instead.
 * - You can use the directive `#pragma unroll_loop_start` and `#pragma unroll_loop_end`
 * in order to unroll a `for` loop in GLSL by the shader preprocessor. The directive has
 * to be placed right above the loop. The loop formatting has to correspond to a defined standard.
 *   - The loop has to be [normalized](https://en.wikipedia.org/wiki/Normalized_loop).
 *   - The loop variable has to be *i*.
 *   - The value `UNROLLED_LOOP_INDEX` will be replaced with the explicitly
 * value of *i* for the given iteration and can be used in preprocessor
 * statements.
 *
 * ```js
 * const material = new THREE.ShaderMaterial( {
 *    uniforms: {
 *        time: { value: 1.0 },
 *        resolution: { value: new THREE.Vector2() }
 *    },
 *    vertexShader: document.getElementById( 'vertexShader' ).textContent,
 *    fragmentShader: document.getElementById( 'fragmentShader' ).textContent
 * } );
 * ```
 */
external class ShaderMaterial : Material, ShaderMaterialProperties {
/**
     * Constructs a new shader material.
     *
     * @param {Object} [parameters] - An object with one or more properties
     * defining the material's appearance. Any property of the material
     * (including any property from inherited materials) can be passed
     * in here. Color values can be passed any type of value accepted
     * by {@link Color#set}.
     */
constructor (parameters: ShaderMaterialParameters = definedExternally)
/**
     * This flag can be used for type testing.
     *
     * @default true
     */
val isShaderMaterial: Boolean
fun setValues(values: ShaderMaterialParameters = definedExternally): Unit
fun toJSON(meta: JSONMeta = definedExternally): ShaderMaterialJSON
var defines: Record<String, Any?>
}

// eslint-disable-next-line @typescript-eslint/no-empty-interface
external interface ShaderMaterialPropertiesUniforms {
operator fun get(key: String): IUniform?

operator fun set(key: String, value: IUniform?)
}

external interface ShaderMaterialPropertiesExtensions {
var clipCullDistance: Boolean
var multiDraw: Boolean
}

external interface ShaderMaterialPropertiesDefaultAttributeValues {
var color: js.array.Tuple3<Double, Double, Double>
var uv: js.array.Tuple2<Double, Double>
var uv1: js.array.Tuple2<Double, Double>
}