// Generated by Karakum - do not modify it manually!

@file:JsModule("threethree")

package three.src.materials

// unhandled import: Camera from "../cameras/Camera.js"
// unhandled import: Blending from "../constants.js"
// unhandled import: BlendingDstFactor from "../constants.js"
// unhandled import: BlendingEquation from "../constants.js"
// unhandled import: BlendingSrcFactor from "../constants.js"
// unhandled import: Combine from "../constants.js"
// unhandled import: DepthModes from "../constants.js"
// unhandled import: NormalMapTypes from "../constants.js"
// unhandled import: Side from "../constants.js"
// unhandled import: StencilFunc from "../constants.js"
// unhandled import: StencilOp from "../constants.js"
// unhandled import: BufferGeometry from "../core/BufferGeometry.js"
// unhandled import: EventDispatcher from "../core/EventDispatcher.js"
// unhandled import: JSONMeta from "../core/Object3D.js"
// unhandled import: Object3D from "../core/Object3D.js"
// unhandled import: Color from "../math/Color.js"
// unhandled import: ColorRepresentation from "../math/Color.js"
// unhandled import: EulerTuple from "../math/Euler.js"
// unhandled import: Plane from "../math/Plane.js"
// unhandled import: Vector2Tuple from "../math/Vector2.js"
// unhandled import: Group from "../objects/Group.js"
// unhandled import: WebGLProgramParametersWithUniforms from "../renderers/webgl/WebGLPrograms.js"
// unhandled import: WebGLRenderer from "../renderers/WebGLRenderer.js"
// unhandled import: Scene from "../scenes/Scene.js"
// unhandled import: SourceJSON from "../textures/Source.js"
// unhandled import: TextureJSON from "../textures/Texture.js"































external interface MaterialProperties {
/**
     * The name of the material.
     */
var name: String
/**
     * Defines the blending type of the material.
     *
     * It must be set to `CustomBlending` if custom blending properties like
     * {@link Material#blendSrc}, {@link Material#blendDst} or {@link Material#blendEquation}
     * should have any effect.
     *
     * @default NormalBlending
     */
var blending: Blending
/**
     * Defines which side of faces will be rendered - front, back or both.
     *
     * @default FrontSide
     */
var side: Side
/**
     * If set to `true`, vertex colors should be used.
     *
     * The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or
     * four (RGBA) component color buffer attribute is used.
     *
     * @default false
     */
var vertexColors: Boolean
/**
     * Defines how transparent the material is.
     * A value of `0.0` indicates fully transparent, `1.0` is fully opaque.
     *
     * If the {@link Material#transparent} is not set to `true`,
     * the material will remain fully opaque and this value will only affect its color.
     *
     * @default 1
     */
var opacity: Double
/**
     * Defines whether this material is transparent. This has an effect on
     * rendering as transparent objects need special treatment and are rendered
     * after non-transparent objects.
     *
     * When set to true, the extent to which the material is transparent is
     * controlled by {@link Material#opacity}.
     *
     * @default false
     */
var transparent: Boolean
/**
     * Enables alpha hashed transparency, an alternative to {@link Material#transparent} or
     * {@link Material#alphaTest}. The material will not be rendered if opacity is lower than
     * a random threshold. Randomization introduces some grain or noise, but approximates alpha
     * blending without the associated problems of sorting. Using TAA can reduce the resulting noise.
     *
     * @default false
     */
var alphaHash: Boolean
/**
     * Defines the blending source factor.
     *
     * @default SrcAlphaFactor
     */
var blendSrc: BlendingSrcFactor
/**
     * Defines the blending destination factor.
     *
     * @default OneMinusSrcAlphaFactor
     */
var blendDst: BlendingDstFactor
/**
     * Defines the blending equation.
     *
     * @default AddEquation
     */
var blendEquation: BlendingEquation
/**
     * Defines the blending source alpha factor.
     *
     * @default null
     */
var blendSrcAlpha: BlendingSrcFactor?
/**
     * Defines the blending destination alpha factor.
     *
     * @default null
     */
var blendDstAlpha: BlendingDstFactor?
/**
     * Defines the blending equation of the alpha channel.
     *
     * @default null
     */
var blendEquationAlpha: BlendingEquation?
/**
     * Represents the RGB values of the constant blend color.
     *
     * This property has only an effect when using custom blending with `ConstantColor` or `OneMinusConstantColor`.
     *
     * @default (0,0,0)
     */
var blendColor: Color
/**
     * Represents the alpha value of the constant blend color.
     *
     * This property has only an effect when using custom blending with `ConstantAlpha` or `OneMinusConstantAlpha`.
     *
     * @default 0
     */
var blendAlpha: Double
/**
     * Defines the depth function.
     *
     * @default LessEqualDepth
     */
var depthFunc: DepthModes
/**
     * Whether to have depth test enabled when rendering this material.
     * When the depth test is disabled, the depth write will also be implicitly disabled.
     *
     * @default true
     */
var depthTest: Boolean
/**
     * Whether rendering this material has any effect on the depth buffer.
     *
     * When drawing 2D overlays it can be useful to disable the depth writing in
     * order to layer several things together without creating z-index artifacts.
     *
     * @default true
     */
var depthWrite: Boolean
/**
     * The bit mask to use when writing to the stencil buffer.
     *
     * @default 0xff
     */
var stencilWriteMask: Double
/**
     * The stencil comparison function to use.
     *
     * @default AlwaysStencilFunc
     */
var stencilFunc: StencilFunc
/**
     * The value to use when performing stencil comparisons or stencil operations.
     *
     * @default 0
     */
var stencilRef: Double
/**
     * The bit mask to use when comparing against the stencil buffer.
     *
     * @default 0xff
     */
var stencilFuncMask: Double
/**
     * Which stencil operation to perform when the comparison function returns `false`.
     *
     * @default KeepStencilOp
     */
var stencilFail: StencilOp
/**
     * Which stencil operation to perform when the comparison function returns
     * `true` but the depth test fails.
     *
     * @default KeepStencilOp
     */
var stencilZFail: StencilOp
/**
     * Which stencil operation to perform when the comparison function returns
     * `true` and the depth test passes.
     *
     * @default KeepStencilOp
     */
var stencilZPass: StencilOp
/**
     * Whether stencil operations are performed against the stencil buffer. In
     * order to perform writes or comparisons against the stencil buffer this
     * value must be `true`.
     *
     * @default false
     */
var stencilWrite: Boolean
/**
     * User-defined clipping planes specified as THREE.Plane objects in world
     * space. These planes apply to the objects this material is attached to.
     * Points in space whose signed distance to the plane is negative are clipped
     * (not rendered). This requires {@link WebGLRenderer#localClippingEnabled} to
     * be `true`.
     *
     * @default null
     */
var clippingPlanes: Array<Plane>?
/**
     * Changes the behavior of clipping planes so that only their intersection is
     * clipped, rather than their union.
     *
     * @default false
     */
var clipIntersection: Boolean
/**
     * Defines whether to clip shadows according to the clipping planes specified
     * on this material.
     *
     * @default false
     */
var clipShadows: Boolean
/**
     * Defines which side of faces cast shadows. If `null`, the side casting shadows
     * is determined as follows:
     *
     * - When {@link Material#side} is set to `FrontSide`, the back side cast shadows.
     * - When {@link Material#side} is set to `BackSide`, the front side cast shadows.
     * - When {@link Material#side} is set to `DoubleSide`, both sides cast shadows.
     *
     * @default null
     */
var shadowSide: Side?
/**
     * Whether to render the material's color.
     *
     * This can be used in conjunction with {@link Object3D#renderOder} to create invisible
     * objects that occlude other objects.
     *
     * @default true
     */
var colorWrite: Boolean
/**
     * Override the renderer's default precision for this material.
     *
     * @default null
     */
var precision: MaterialPropertiesPrecision?
/**
     * Whether to use polygon offset or not. When enabled, each fragment's depth value will
     * be offset after it is interpolated from the depth values of the appropriate vertices.
     * The offset is added before the depth test is performed and before the value is written
     * into the depth buffer.
     *
     * Can be useful for rendering hidden-line images, for applying decals to surfaces, and for
     * rendering solids with highlighted edges.
     *
     * @default false
     */
var polygonOffset: Boolean
/**
     * Specifies a scale factor that is used to create a variable depth offset for each polygon.
     *
     * @default 0
     */
var polygonOffsetFactor: Double
/**
     * Is multiplied by an implementation-specific value to create a constant depth offset.
     *
     * @default 0
     */
var polygonOffsetUnits: Double
/**
     * Whether to apply dithering to the color to remove the appearance of banding.
     *
     * @default false
     */
var dithering: Boolean
/**
     * Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts
     * (meaning when the renderer was created with *antialias* parameter set to `true`). Enabling this
     * will smooth aliasing on clip plane edges and alphaTest-clipped edges.
     *
     * @default false
     */
var alphaToCoverage: Boolean
/**
     * Whether to premultiply the alpha (transparency) value.
     *
     * @default false
     */
var premultipliedAlpha: Boolean
/**
     * Whether double-sided, transparent objects should be rendered with a single pass or not.
     *
     * The engine renders double-sided, transparent objects with two draw calls (back faces first,
     * then front faces) to mitigate transparency artifacts. There are scenarios however where this
     * approach produces no quality gains but still doubles draw calls e.g. when rendering flat
     * vegetation like grass sprites. In these cases, set the `forceSinglePass` flag to `true` to
     * disable the two pass rendering to avoid performance issues.
     *
     * @default false
     */
var forceSinglePass: Boolean
/**
     * Whether it's possible to override the material with {@link Scene#overrideMaterial} or not.
     *
     * @default true
     */
var allowOverride: Boolean
/**
     * Defines whether 3D objects using this material are visible.
     *
     * @default true
     */
var visible: Boolean
/**
     * Defines whether this material is tone mapped according to the renderer's tone mapping setting.
     *
     * It is ignored when rendering to a render target or using post processing or when using
     * `WebGPURenderer`. In all these cases, all materials are honored by tone mapping.
     *
     * @default true
     */
var toneMapped: Boolean
/**
     * An object that can be used to store custom data about the Material. It
     * should not hold references to functions as these will not be cloned.
     */
var userData: Record<String, Any?>
var alphaTest: Double
}

external interface MapColorPropertiesToColorRepresentations<T> {
operator fun <P : /* keyof T */> get(key: P): (Any /* T[P] extends Color ? ColorRepresentation : T[P] */)?

operator fun <P : /* keyof T */> set(key: P, value: (Any /* T[P] extends Color ? ColorRepresentation : T[P] */)?)
}

// eslint-disable-next-line @typescript-eslint/no-empty-interface
external interface MaterialParameters : Partial<MapColorPropertiesToColorRepresentations<MaterialProperties>> {

}

external interface MaterialJSON {
var metadata: MaterialJSONMetadata
var uuid: String
var type: String
var name: String?
var color: Double?
var roughness: Double?
var metalness: Double?
var sheen: Double?
var sheenColor: Double?
var sheenRoughness: Double?
var emissive: Double?
var emissiveIntensity: Double?
var specular: Double?
var specularIntensity: Double?
var specularColor: Double?
var shininess: Double?
var clearcoat: Double?
var clearcoatRoughness: Double?
var clearcoatMap: String?
var clearcoatRoughnessMap: String?
var clearcoatNormalMap: String?
var clearcoatNormalScale: Vector2Tuple?
var dispersion: Double?
var iridescence: Double?
var iridescenceIOR: Double?
var iridescenceThicknessRange: Double?
var iridescenceMap: String?
var iridescenceThicknessMap: String?
var anisotropy: Double?
var anisotropyRotation: Double?
var anisotropyMap: String?
var map: String?
var matcap: String?
var alphaMap: String?
var lightMap: String?
var lightMapIntensity: Double?
var aoMap: String?
var aoMapIntensity: Double?
var bumpMap: String?
var bumpScale: Double?
var normalMap: String?
var normalMapType: NormalMapTypes?
var normalScale: Vector2Tuple?
var displacementMap: String?
var displacementScale: Double?
var displacementBias: Double?
var roughnessMap: String?
var metalnessMap: String?
var emissiveMap: String?
var specularMap: String?
var specularIntensityMap: String?
var specularColorMap: String?
var envMap: String?
var combine: Combine?
var envMapRotation: EulerTuple?
var envMapIntensity: Double?
var reflectivity: Double?
var refractionRatio: Double?
var gradientMap: String?
var transmission: Double?
var transmissionMap: String?
var thickness: Double?
var thicknessMap: String?
var attenuationDistance: Double?
var attenuationColor: Double?
var size: Double?
var shadowSide: Double?
var sizeAttenuation: Boolean?
var blending: Blending?
var side: Side?
var vertexColors: Boolean?
var opacity: Double?
var transparent: Boolean?
var blendSrc: BlendingSrcFactor?
var blendDst: BlendingDstFactor?
var blendEquation: BlendingEquation?
var blendSrcAlpha: Double?
var blendDstAlpha: Double?
var blendEquationAlpha: Double?
var blendColor: Double?
var blendAlpha: Double?
var depthFunc: DepthModes?
var depthTest: Boolean?
var depthWrite: Boolean?
var colorWrite: Boolean?
var stencilWriteMask: Double?
var stencilFunc: StencilFunc?
var stencilRef: Double?
var stencilFuncMask: Double?
var stencilFail: StencilOp?
var stencilZFail: StencilOp?
var stencilZPass: StencilOp?
var stencilWrite: Boolean?
var rotation: Double?
var polygonOffset: Boolean?
var polygonOffsetFactor: Double?
var polygonOffsetUnits: Double?
var linewidth: Double?
var dashSize: Double?
var gapSize: Double?
var scale: Double?
var dithering: Boolean?
var alphaTest: Double?
var alphaHash: Boolean?
var alphaToCoverage: Boolean?
var premultipliedAlpha: Boolean?
var forceSinglePass: Boolean?
var wireframe: Boolean?
var wireframeLinewidth: Double?
var wireframeLinecap: String?
var wireframeLinejoin: String?
var flatShading: Boolean?
var visible: Boolean?
var toneMapped: Boolean?
var fog: Boolean?
var userData: Record<String, Any?>?
var textures: Array<Omit<TextureJSON, String /* "metadata" */>>?
var images: js.array.ReadonlyArray<SourceJSON>?
}

/**
 * Abstract base class for materials.
 *
 * Materials define the appearance of renderable 3D objects.
 *
 * @abstract
 */
external class Material : EventDispatcher<Temp45>, MaterialProperties {
/**
     * This flag can be used for type testing.
     *
     * @default true
     */
val isMaterial: Boolean
/**
     * The UUID of the material.
     */
val uuid: String
/**
     * The type property is used for detecting the object type
     * in context of serialization/deserialization.
     */
var type: String
/**
     * This starts at `0` and counts how many times {@link Material#needsUpdate} is set to `true`.
     *
     * @default 0
     */
val version: Double
var defines: Record<String, Any?>?
/**
     * An optional callback that is executed immediately before the material is used to render a 3D object.
     *
     * This method can only be used when rendering with {@link WebGLRenderer}.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {Scene} scene - The scene.
     * @param {Camera} camera - The camera that is used to render the scene.
     * @param {BufferGeometry} geometry - The 3D object's geometry.
     * @param {Object3D} object - The 3D object.
     * @param {Object} group - The geometry group data.
     */
fun onBeforeRender(renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry, `object`: Object3D, group: Group): Unit
/**
     * An optional callback that is executed immediately before the shader
     * program is compiled. This function is called with the shader source code
     * as a parameter. Useful for the modification of built-in materials.
     *
     * This method can only be used when rendering with {@link WebGLRenderer}. The
     * recommended approach when customizing materials is to use `WebGPURenderer` with the new
     * Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language).
     *
     * @param {{vertexShader:string,fragmentShader:string,uniforms:Object}} shaderobject - The object holds the uniforms and the vertex and fragment shader source.
     * @param {WebGLRenderer} renderer - A reference to the renderer.
     */
fun onBeforeCompile(parameters: WebGLProgramParametersWithUniforms, renderer: WebGLRenderer): Unit
/**
     * In case {@link Material#onBeforeCompile} is used, this callback can be used to identify
     * values of settings used in `onBeforeCompile()`, so three.js can reuse a cached
     * shader or recompile the shader for this material as needed.
     *
     * This method can only be used when rendering with {@link WebGLRenderer}.
     *
     * @return {string} The custom program cache key.
     */
fun customProgramCacheKey(): String
/**
     * This method can be used to set default values from parameter objects.
     * It is a generic implementation so it can be used with different types
     * of materials.
     *
     * @param {Object} [values] - The material values to set.
     */
fun setValues(values: MaterialParameters = definedExternally): Unit
/**
     * Serializes the material into JSON.
     *
     * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
     * @return {Object} A JSON object representing the serialized material.
     * @see {@link ObjectLoader#parse}
     */
fun toJSON(meta: JSONMeta = definedExternally): MaterialJSON
/**
     * Returns a new material with copied values from this instance.
     *
     * @return {Material} A clone of this instance.
     */
fun clone(): Unit /* this */
/**
     * Copies the values of the given material to this instance.
     *
     * @param {Material} source - The material to copy.
     * @return {Material} A reference to this instance.
     */
fun copy(source: Material): Unit /* this */
/**
     * Frees the GPU-related resources allocated by this instance. Call this
     * method whenever this instance is no longer used in your app.
     *
     * @fires Material#dispose
     */
fun dispose(): Unit
/**
     * Setting this property to `true` indicates the engine the material
     * needs to be recompiled.
     *
     * @default false
     * @param {boolean} value
     */
var needsUpdate: Boolean
}

// eslint-disable-next-line @typescript-eslint/no-empty-interface
external interface MaterialJSONMetadata {
var version: Double
var type: String
var generator: String
}

external interface Temp45 {
var dispose: Any
}

sealed external interface MaterialPropertiesPrecision {
companion object {
@seskar.js.JsValue("highp")
val highp: MaterialPropertiesPrecision
@seskar.js.JsValue("mediump")
val mediump: MaterialPropertiesPrecision
@seskar.js.JsValue("lowp")
val lowp: MaterialPropertiesPrecision
}
}