// Generated by Karakum - do not modify it manually!

@file:JsModule("threethree")

package three.src.animation

// unhandled import: InterpolationModes from "../constants.js"
// unhandled import: TypedArray from "../core/BufferAttribute.js"
// unhandled import: TypedArrayConstructor from "../core/BufferAttribute.js"
// unhandled import: CubicInterpolant from "../math/interpolants/CubicInterpolant.js"
// unhandled import: DiscreteInterpolant from "../math/interpolants/DiscreteInterpolant.js"
// unhandled import: LinearInterpolant from "../math/interpolants/LinearInterpolant.js"











external interface KeyframeTrackJSON {
var name: String
var times: js.array.ReadonlyArray<Double>
var values: js.array.ReadonlyArray<Double>
var interpolation: InterpolationModes?
var type: String
}

/**
 * Represents s a timed sequence of keyframes, which are composed of lists of
 * times and related values, and which are used to animate a specific property
 * of an object.
 */
external class KeyframeTrack {
/**
     * Constructs a new keyframe track.
     *
     * @param {string} name - The keyframe track's name.
     * @param {Array<number>} times - A list of keyframe times.
     * @param {Array<number|string|boolean>} values - A list of keyframe values.
     * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
     */
constructor (name: String, times: ArrayLike<Double>, values: ArrayLike<Any /* number | string | boolean */>, interpolation: InterpolationModes = definedExternally)
/**
     * The track's name can refer to morph targets or bones or
     * possibly other values within an animated object. See {@link PropertyBinding#parseTrackName}
     * for the forms of strings that can be parsed for property binding.
     */
var name: String
/**
     * The keyframe times.
     */
var times: Float32Array
/**
     * The keyframe values.
     */
var values: Float32Array
/**
     * Factory method for creating a new discrete interpolant.
     *
     * @static
     * @param {TypedArray} [result] - The result buffer.
     * @return {DiscreteInterpolant} The new interpolant.
     */
fun InterpolantFactoryMethodDiscrete(result: TypedArray = definedExternally): DiscreteInterpolant
/**
     * Factory method for creating a new linear interpolant.
     *
     * @static
     * @param {TypedArray} [result] - The result buffer.
     * @return {LinearInterpolant} The new interpolant.
     */
fun InterpolantFactoryMethodLinear(result: TypedArray = definedExternally): LinearInterpolant
/**
     * Factory method for creating a new smooth interpolant.
     *
     * @static
     * @param {TypedArray} [result] - The result buffer.
     * @return {CubicInterpolant} The new interpolant.
     */
fun InterpolantFactoryMethodSmooth(result: TypedArray = definedExternally): CubicInterpolant
/**
     * Defines the interpolation factor method for this keyframe track.
     *
     * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} interpolation - The interpolation type.
     * @return {KeyframeTrack} A reference to this keyframe track.
     */
fun setInterpolation(interpolation: InterpolationModes): KeyframeTrack
/**
     * Returns the current interpolation type.
     *
     * @return {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} The interpolation type.
     */
fun getInterpolation(): InterpolationModes
/**
     * Returns the value size.
     *
     * @return {number} The value size.
     */
fun getValueSize(): Double
/**
     * Moves all keyframes either forward or backward in time.
     *
     * @param {number} timeOffset - The offset to move the time values.
     * @return {KeyframeTrack} A reference to this keyframe track.
     */
fun shift(timeOffset: Double): KeyframeTrack
/**
     * Scale all keyframe times by a factor (useful for frame - seconds conversions).
     *
     * @param {number} timeScale - The time scale.
     * @return {KeyframeTrack} A reference to this keyframe track.
     */
fun scale(timeScale: Double): KeyframeTrack
/**
     * Removes keyframes before and after animation without changing any values within the defined time range.
     *
     * Note: The method does not shift around keys to the start of the track time, because for interpolated
     * keys this will change their values
     *
     * @param {number} startTime - The start time.
     * @param {number} endTime - The end time.
     * @return {KeyframeTrack} A reference to this keyframe track.
     */
fun trim(startTime: Double, endTime: Double): KeyframeTrack
/**
     * Performs minimal validation on the keyframe track. Returns `true` if the values
     * are valid.
     *
     * @return {boolean} Whether the keyframes are valid or not.
     */
fun validate(): Boolean
/**
     * Optimizes this keyframe track by removing equivalent sequential keys (which are
     * common in morph target sequences).
     *
     * @return {AnimationClip} A reference to this animation clip.
     */
fun optimize(): Unit /* this */
/**
     * Returns a new keyframe track with copied values from this instance.
     *
     * @return {KeyframeTrack} A clone of this instance.
     */
fun clone(): Unit /* this */
/**
     * The value type name.
     *
     * @default ''
     */
var ValueTypeName: String
/**
     * The time buffer type of this keyframe track.
     *
     * @default Float32Array.constructor
     */
var TimeBufferType: Any /* TypedArrayConstructor | ArrayConstructor */
/**
     * The value buffer type of this keyframe track.
     *
     * @default Float32Array.constructor
     */
var ValueBufferType: Any /* TypedArrayConstructor | ArrayConstructor */
/**
     * The default interpolation type of this keyframe track.
     *
     * @default InterpolateLinear
     */
var DefaultInterpolation: InterpolationModes
companion object {
/**
     * Converts the keyframe track to JSON.
     *
     * @static
     * @param {KeyframeTrack} track - The keyframe track to serialize.
     * @return {Object} The serialized keyframe track as JSON.
     */
fun toJSON(track: KeyframeTrack): KeyframeTrackJSON
}
}
