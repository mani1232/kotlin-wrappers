// Generated by Karakum - do not modify it manually!

@file:JsModule("threethree")

package three.src.materials.nodes

// unhandled import: default as ClippingNode from "../../nodes/accessors/ClippingNode.js"
// unhandled import: default as ContextNode from "../../nodes/core/ContextNode.js"
// unhandled import: default as LightingModel from "../../nodes/core/LightingModel.js"
// unhandled import: default as MRTNode from "../../nodes/core/MRTNode.js"
// unhandled import: default as Node from "../../nodes/core/Node.js"
// unhandled import: default as NodeBuilder from "../../nodes/core/NodeBuilder.js"
// unhandled import: default as LightsNode from "../../nodes/lighting/LightsNode.js"
// unhandled import: MapColorPropertiesToColorRepresentations from "../Material.js"
// unhandled import: Material from "../Material.js"
// unhandled import: MaterialParameters from "../Material.js"
// unhandled import: default as NodeMaterialObserver from "./manager/NodeMaterialObserver.js"



















external interface NodeMaterialNodeProperties {
/**
     * Whether this material is affected by fog or not.
     *
     * @default true
     */
var fog: Boolean
/**
     * Whether this material is affected by lights or not.
     *
     * @default false
     */
var lights: Boolean
/**
     * Whether this material uses hardware clipping or not.
     * This property is managed by the engine and should not be
     * modified by apps.
     *
     * @default false
     */
var hardwareClipping: Boolean
/**
     * Node materials which set their `lights` property to `true`
     * are affected by all lights of the scene. Sometimes selective
     * lighting is wanted which means only _some_ lights in the scene
     * affect a material. This can be achieved by creating an instance
     * of {@link LightsNode} with a list of selective
     * lights and assign the node to this property.
     *
     * ```js
     * const customLightsNode = lights( [ light1, light2 ] );
     * material.lightsNode = customLightsNode;
     * ```
     *
     * @default null
     */
var lightsNode: LightsNode?
/**
     * The environment of node materials can be defined by an environment
     * map assigned to the `envMap` property or by `Scene.environment`
     * if the node material is a PBR material. This node property allows to overwrite
     * the default behavior and define the environment with a custom node.
     *
     * ```js
     * material.envNode = pmremTexture( renderTarget.texture );
     * ```
     *
     * @default null
     */
var envNode: Node?
/**
     * The lighting of node materials might be influenced by ambient occlusion.
     * The default AO is inferred from an ambient occlusion map assigned to `aoMap`
     * and the respective `aoMapIntensity`. This node property allows to overwrite
     * the default and define the ambient occlusion with a custom node instead.
     *
     * If you don't want to overwrite the diffuse color but modify the existing
     * values instead, use {@link materialAO}.
     *
     * @default null
     */
var aoNode: Node?
/**
     * The diffuse color of node materials is by default inferred from the
     * `color` and `map` properties. This node property allows to overwrite the default
     * and define the diffuse color with a node instead.
     *
     * ```js
     * material.colorNode = color( 0xff0000 ); // define red color
     * ```
     *
     * If you don't want to overwrite the diffuse color but modify the existing
     * values instead, use {@link materialColor}.
     *
     * ```js
     * material.colorNode = materialColor.mul( color( 0xff0000 ) ); // give diffuse colors a red tint
     * ```
     *
     * @default null
     */
var colorNode: Node?
/**
     * The normals of node materials are by default inferred from the `normalMap`/`normalScale`
     * or `bumpMap`/`bumpScale` properties. This node property allows to overwrite the default
     * and define the normals with a node instead.
     *
     * If you don't want to overwrite the normals but modify the existing values instead,
     * use {@link materialNormal}.
     *
     * @default null
     */
var normalNode: Node?
/**
     * The opacity of node materials is by default inferred from the `opacity`
     * and `alphaMap` properties. This node property allows to overwrite the default
     * and define the opacity with a node instead.
     *
     * If you don't want to overwrite the opacity but modify the existing
     * value instead, use {@link materialOpacity}.
     *
     * @default null
     */
var opacityNode: Node?
/**
     * This node can be used to implement a variety of filter-like effects. The idea is
     * to store the current rendering into a texture e.g. via `viewportSharedTexture()`, use it
     * to create an arbitrary effect and then assign the node composition to this property.
     * Everything behind the object using this material will now be affected by a filter.
     *
     * ```js
     * const material = new NodeMaterial()
     * material.transparent = true;
     *
     * // everything behind the object will be monochromatic
     * material.backdropNode = saturation( viewportSharedTexture().rgb, 0 );
     * ```
     *
     * Backdrop computations are part of the lighting so only lit materials can use this property.
     *
     * @default null
     */
var backdropNode: Node?
/**
     * This node allows to modulate the influence of `backdropNode` to the outgoing light.
     *
     * @default null
     */
var backdropAlphaNode: Node?
/**
     * The alpha test of node materials is by default inferred from the `alphaTest`
     * property. This node property allows to overwrite the default and define the
     * alpha test with a node instead.
     *
     * If you don't want to overwrite the alpha test but modify the existing
     * value instead, use {@link materialAlphaTest}.
     *
     * @default null
     */
var alphaTestNode: Node?
/**
     * Discards the fragment if the mask value is `false`.
     *
     * @default null
     */
var maskNode: Node?
/**
     * The local vertex positions are computed based on multiple factors like the
     * attribute data, morphing or skinning. This node property allows to overwrite
     * the default and define local vertex positions with nodes instead.
     *
     * If you don't want to overwrite the vertex positions but modify the existing
     * values instead, use {@link positionLocal}.
     *
     * ```js
     * material.positionNode = positionLocal.add( displace );
     * ```
     *
     * @default null
     */
var positionNode: Node?
/**
     * This node property is intended for logic which modifies geometry data once or per animation step.
     * Apps usually place such logic randomly in initialization routines or in the animation loop.
     * `geometryNode` is intended as a dedicated API so there is an intended spot where geometry modifications
     * can be implemented.
     *
     * The idea is to assign a `Fn` definition that holds the geometry modification logic. A typical example
     * would be a GPU based particle system that provides a node material for usage on app level. The particle
     * simulation would be implemented as compute shaders and managed inside a `Fn` function. This function is
     * eventually assigned to `geometryNode`.
     *
     * @default null
     */
var geometryNode: (() -> Node)?
/**
     * Allows to overwrite depth values in the fragment shader.
     *
     * @default null
     */
var depthNode: Node?
/**
     * Allows to overwrite the position used for shadow map rendering which
     * is by default {@link positionWorld}, the vertex position
     * in world space.
     *
     * @default null
     */
var receivedShadowPositionNode: Node?
/**
     * Allows to overwrite the geometry position used for shadow map projection which
     * is by default {@link positionLocal}, the vertex position in local space.
     *
     * @default null
     */
var castShadowPositionNode: Node?
/**
     * This node can be used to influence how an object using this node material
     * receive shadows.
     *
     * ```js
     * const totalShadows = float( 1 ).toVar();
     * material.receivedShadowNode = Fn( ( [ shadow ] ) => {
     * 	totalShadows.mulAssign( shadow );
     * 	//return float( 1 ); // bypass received shadows
     * 	return shadow.mix( color( 0xff0000 ), 1 ); // modify shadow color
     * } );
     *
     * @default null
     */
var receivedShadowNode: (() -> Node)?
/**
     * This node can be used to influence how an object using this node material
     * casts shadows. To apply a color to shadows, you can simply do:
     *
     * ```js
     * material.castShadowNode = vec4( 1, 0, 0, 1 );
     * ```
     *
     * Which can be nice to fake colored shadows of semi-transparent objects. It
     * is also common to use the property with `Fn` function so checks are performed
     * per fragment.
     *
     * ```js
     * materialCustomShadow.castShadowNode = Fn( () => {
     * 	hash( vertexIndex ).greaterThan( 0.5 ).discard();
     * 	return materialColor;
     * } )();
     *  ```
     *
     * @default null
     */
var castShadowNode: Node?
/**
     * This node can be used to define the final output of the material.
     *
     * TODO: Explain the differences to `fragmentNode`.
     *
     * @default null
     */
var outputNode: Node?
/**
     * MRT configuration is done on renderer or pass level. This node allows to
     * overwrite what values are written into MRT targets on material level. This
     * can be useful for implementing selective FX features that should only affect
     * specific objects.
     *
     * @default null
     */
var mrtNode: MRTNode?
/**
     * This node property can be used if you need complete freedom in implementing
     * the fragment shader. Assigning a node will replace the built-in material
     * logic used in the fragment stage.
     *
     * @default null
     */
var fragmentNode: Node?
/**
     * This node property can be used if you need complete freedom in implementing
     * the vertex shader. Assigning a node will replace the built-in material logic
     * used in the vertex stage.
     *
     * @default null
     */
var vertexNode: Node?
/**
     * This node can be used as a global context management component for this material.
     *
     * @default null
     */
var contextNode: ContextNode?
}

// eslint-disable-next-line @typescript-eslint/no-empty-interface
external interface NodeMaterialParameters : Partial<MapColorPropertiesToColorRepresentations<NodeMaterialNodeProperties>>, MaterialParameters {

}

/**
 * Base class for all node materials.
 */
external class NodeMaterial : Material, NodeMaterialNodeProperties {
/**
     * This flag can be used for type testing.
     *
     * @default true
     */
val isNodeMaterial: Boolean
fun setValues(values: NodeMaterialParameters = definedExternally): Unit
/**
     * Builds this material with the given node builder.
     *
     * @param {NodeBuilder} builder - The current node builder.
     */
fun build(builder: NodeBuilder): Unit
/**
     * Setups a node material observer with the given builder.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {NodeMaterialObserver} The node material observer.
     */
fun setupObserver(builder: NodeBuilder): NodeMaterialObserver
/**
     * Setups the vertex and fragment stage of this node material.
     *
     * @param {NodeBuilder} builder - The current node builder.
     */
fun setup(builder: NodeBuilder): Unit
/**
     * Setups the clipping node.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {ClippingNode} The clipping node.
     */
fun setupClipping(builder: NodeBuilder): ClippingNode
/**
     * Setups the hardware clipping if available on the current device.
     *
     * @param {NodeBuilder} builder - The current node builder.
     */
fun setupHardwareClipping(builder: NodeBuilder): Unit
/**
     * Setups the depth of this material.
     *
     * @param {NodeBuilder} builder - The current node builder.
     */
fun setupDepth(builder: NodeBuilder): Unit
/**
     * Setups the position node in view space. This method exists
     * so derived node materials can modify the implementation e.g. sprite materials.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {Node<vec3>} The position in view space.
     */
fun setupPositionView(builder: NodeBuilder): Node
/**
     * Setups the position in clip space.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {Node<vec4>} The position in view space.
     */
fun setupModelViewProjection(): Node
/**
     * Setups the logic for the vertex stage.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {Node<vec4>} The position in clip space.
     */
fun setupVertex(builder: NodeBuilder): Node
/**
     * Setups the computation of the position in local space.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {Node<vec3>} The position in local space.
     */
fun setupPosition(builder: NodeBuilder): Node
/**
     * Setups the computation of the material's diffuse color.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @param {BufferGeometry} geometry - The geometry.
     */
fun setupDiffuseColor(builder: NodeBuilder): Unit
/**
     * Abstract interface method that can be implemented by derived materials
     * to setup material-specific node variables.
     *
     * @abstract
     * @param {NodeBuilder} builder - The current node builder.
     */
fun setupVariants(builder: NodeBuilder): Unit
/**
     * Setups the outgoing light node variable
     *
     * @return {Node<vec3>} The outgoing light node.
     */
fun setupOutgoingLight(): Node
/**
     * Setups the normal node from the material.
     *
     * @return {Node<vec3>} The normal node.
     */
fun setupNormal(): Node
/**
     * Setups the environment node from the material.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {Node<vec4>} The environment node.
     */
fun setupEnvironment(builder: NodeBuilder): Node?
/**
     * Setups the light map node from the material.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {Node<vec3>} The light map node.
     */
fun setupLightMap(builder: NodeBuilder): Node
/**
     * Setups the lights node based on the scene, environment and material.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {LightsNode} The lights node.
     */
fun setupLights(builder: NodeBuilder): LightsNode
/**
     * This method should be implemented by most derived materials
     * since it defines the material's lighting model.
     *
     * @abstract
     * @param {NodeBuilder} builder - The current node builder.
     * @return {LightingModel} The lighting model.
     */
fun setupLightingModel(): LightingModel
/**
     * Setups the outgoing light node.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {Node<vec3>} The outgoing light node.
     */
fun setupLighting(builder: NodeBuilder): Node
/**
     * Setup the fog.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @param {Node<vec4>} outputNode - The existing output node.
     * @return {Node<vec4>} The output node.
     */
fun setupFog(builder: NodeBuilder, outputNode: Node): Node
/**
     * Setups premultiplied alpha.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @param {Node<vec4>} outputNode - The existing output node.
     * @return {Node<vec4>} The output node.
     */
fun setupPremultipliedAlpha(builder: NodeBuilder, outputNode: Node): Node
/**
     * Setups the output node.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @param {Node<vec4>} outputNode - The existing output node.
     * @return {Node<vec4>} The output node.
     */
fun setupOutput(builder: NodeBuilder, outputNode: Node): Node
/**
     * Most classic material types have a node pendant e.g. for `MeshBasicMaterial`
     * there is `MeshBasicNodeMaterial`. This utility method is intended for
     * defining all material properties of the classic type in the node type.
     *
     * @param {Material} material - The material to copy properties with their values to this node material.
     */
fun setDefaultValues(material: Material): Unit
/**
     * Copies the properties of the given node material to this instance.
     *
     * @param {NodeMaterial} source - The material to copy.
     * @return {NodeMaterial} A reference to this node material.
     */
fun copy(source: NodeMaterial): Unit /* this */
companion object {
val type: String
}
}

// eslint-disable-next-line @typescript-eslint/no-empty-interface


/* export default NodeMaterial; */
