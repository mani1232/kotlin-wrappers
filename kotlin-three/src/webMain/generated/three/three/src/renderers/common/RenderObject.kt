// Generated by Karakum - do not modify it manually!

@file:JsModule("threethree")

package three.src.renderers.common

// unhandled import: Camera from "../../cameras/Camera.js"
// unhandled import: BufferAttribute from "../../core/BufferAttribute.js"
// unhandled import: BufferGeometry from "../../core/BufferGeometry.js"
// unhandled import: InterleavedBuffer from "../../core/InterleavedBuffer.js"
// unhandled import: InterleavedBufferAttribute from "../../core/InterleavedBufferAttribute.js"
// unhandled import: Object3D from "../../core/Object3D.js"
// unhandled import: Material from "../../materials/Material.js"
// unhandled import: default as NodeMaterialObserver from "../../materials/nodes/manager/NodeMaterialObserver.js"
// unhandled import: LightsNode from "../../nodes/Nodes.js"
// unhandled import: Scene from "../../scenes/Scene.js"
// unhandled import: default as BindGroup from "./BindGroup.js"
// unhandled import: default as BundleGroup from "./BundleGroup.js"
// unhandled import: default as ClippingContext from "./ClippingContext.js"
// unhandled import: default as Geometries from "./Geometries.js"
// unhandled import: default as NodeBuilderState from "./nodes/NodeBuilderState.js"
// unhandled import: default as Nodes from "./nodes/Nodes.js"
// unhandled import: default as RenderContext from "./RenderContext.js"
// unhandled import: default as Renderer from "./Renderer.js"
// unhandled import: default as RenderPipeline from "./RenderPipeline.js"







































/**
 * A render object is the renderer's representation of single entity that gets drawn
 * with a draw command. There is no unique mapping of render objects to 3D objects in the
 * scene since render objects also depend from the used material, the current render context
 * and the current scene's lighting.
 *
 * In general, the basic process of the renderer is:
 *
 * - Analyze the 3D objects in the scene and generate render lists containing render items.
 * - Process the render lists by calling one or more render commands for each render item.
 * - For each render command, request a render object and perform the draw.
 *
 * The module provides an interface to get data required for the draw command like the actual
 * draw parameters or vertex buffers. It also holds a series of caching related methods since
 * creating render objects should only be done when necessary.
 *
 * @private
 */
external class RenderObject {
/**
     * Constructs a new render object.
     *
     * @param {Nodes} nodes - Renderer component for managing nodes related logic.
     * @param {Geometries} geometries - Renderer component for managing geometries.
     * @param {Renderer} renderer - The renderer.
     * @param {Object3D} object - The 3D object.
     * @param {Material} material - The 3D object's material.
     * @param {Scene} scene - The scene the 3D object belongs to.
     * @param {Camera} camera - The camera the object should be rendered with.
     * @param {LightsNode} lightsNode - The lights node.
     * @param {RenderContext} renderContext - The render context.
     * @param {ClippingContext} clippingContext - The clipping context.
     */
constructor (nodes: Nodes, geometries: Geometries, renderer: Renderer, `object`: Object3D, material: Material, scene: Scene, camera: Camera, lightsNode: LightsNode, renderContext: RenderContext, clippingContext: ClippingContext?)
var _nodes: Nodes
var _geometries: Geometries
var id: Double
var renderer: Renderer
var `object`: Object3D
var material: Material
var scene: Scene
var camera: Camera
var lightsNode: LightsNode
var context: RenderContext
var geometry: BufferGeometry
var version: Double
var drawRange: (Temp84)?
var attributes: Array<Any /* BufferAttribute | InterleavedBufferAttribute */>?
var attributesId: (Temp85)?
var pipeline: RenderPipeline?
var group: (Temp86)?
var vertexBuffers: Array<Any /* BufferAttribute | InterleavedBuffer */>?
var drawParams: (Temp87)?
var bundle: BundleGroup?
var clippingContext: ClippingContext?
var clippingContextCacheKey: String
var initialNodesCacheKey: Double
var initialCacheKey: Double
var _nodeBuilderState: NodeBuilderState?
var _bindings: js.array.ReadonlyArray<BindGroup>?
var _monitor: NodeMaterialObserver?
var onDispose: (() -> Unit)?
val isRenderObject: Boolean /* true */
var onMaterialDispose: () -> Unit
var onGeometryDispose: () -> Unit
/**
     * Updates the clipping context.
     *
     * @param {ClippingContext} context - The clipping context to set.
     */
fun updateClipping(context: ClippingContext): Unit
/**
     * Whether the clipping requires an update or not.
     *
     * @type {boolean}
     * @readonly
     */
val clippingNeedsUpdate: Boolean
/**
     * The number of clipping planes defined in context of hardware clipping.
     *
     * @type {number}
     * @readonly
     */
val hardwareClippingPlanes: Double
/**
     * Returns the node builder state of this render object.
     *
     * @return {NodeBuilderState} The node builder state.
     */
fun getNodeBuilderState(): NodeBuilderState
/**
     * Returns the node material observer of this render object.
     *
     * @return {NodeMaterialObserver} The node material observer.
     */
fun getMonitor(): NodeMaterialObserver
/**
     * Returns an array of bind groups of this render object.
     *
     * @return {Array<BindGroup>} The bindings.
     */
fun getBindings(): js.array.ReadonlyArray<BindGroup>
/**
     * Returns a binding group by group name of this render object.
     *
     * @param {string} name - The name of the binding group.
     * @return {?BindGroup} The bindings.
     */
fun getBindingGroup(name: String): BindGroup?
/**
     * Returns the index of the render object's geometry.
     *
     * @return {?BufferAttribute} The index. Returns `null` for non-indexed geometries.
     */
fun getIndex(): BufferAttribute?
/**
     * Returns the indirect buffer attribute.
     *
     * @return {?BufferAttribute} The indirect attribute. `null` if no indirect drawing is used.
     */
fun getIndirect(): (/* import("./IndirectStorageBufferAttribute.js") */ default)?
/**
     * Returns the byte offset into the indirect attribute buffer.
     *
     * @return {number|Array<number>} The byte offset into the indirect attribute buffer.
     */
fun getIndirectOffset(): Any /* number | number[] */
/**
     * Returns an array that acts as a key for identifying the render object in a chain map.
     *
     * @return {Array<Object>} An array with object references.
     */
fun getChainArray(): /* readonly [
    Object3D<import("../../core/Object3D.js").Object3DEventMap>,
    Material,
    RenderContext,
    LightsNode
] */
/**
     * This method is used when the geometry of a 3D object has been exchanged and the
     * respective render object now requires an update.
     *
     * @param {BufferGeometry} geometry - The geometry to set.
     */
fun setGeometry(geometry: BufferGeometry): Unit
/**
     * Returns the buffer attributes of the render object. The returned array holds
     * attribute definitions on geometry and node level.
     *
     * @return {Array<BufferAttribute>} An array with buffer attributes.
     */
fun getAttributes(): js.array.ReadonlyArray<(Any /* BufferAttribute | InterleavedBufferAttribute */)>
/**
     * Returns the vertex buffers of the render object.
     *
     * @return {Array<BufferAttribute|InterleavedBuffer>} An array with buffer attribute or interleaved buffers.
     */
fun getVertexBuffers(): js.array.ReadonlyArray<(Any /* BufferAttribute | InterleavedBuffer */)>?
/**
     * Returns the draw parameters for the render object.
     *
     * @return {?{vertexCount: number, firstVertex: number, instanceCount: number, firstInstance: number}} The draw parameters.
     */
fun getDrawParameters(): (Temp88)?
/**
     * Returns the render object's geometry cache key.
     *
     * The geometry cache key is part of the material cache key.
     *
     * @return {string} The geometry cache key.
     */
fun getGeometryCacheKey(): String
/**
     * Returns the render object's material cache key.
     *
     * The material cache key is part of the render object cache key.
     *
     * @return {number} The material cache key.
     */
fun getMaterialCacheKey(): Double
/**
     * Whether the geometry requires an update or not.
     *
     * @type {boolean}
     * @readonly
     */
val needsGeometryUpdate: Boolean
/**
     * Whether the render object requires an update or not.
     *
     * Note: There are two distinct places where render objects are checked for an update.
     *
     * 1. In `RenderObjects.get()` which is executed when the render object is request. This
     * method checks the `needsUpdate` flag and recreates the render object if necessary.
     * 2. In `Renderer._renderObjectDirect()` right after getting the render object via
     * `RenderObjects.get()`. The render object's NodeMaterialObserver is then used to detect
     * a need for a refresh due to material, geometry or object related value changes.
     *
     * TODO: Investigate if it's possible to merge both steps so there is only a single place
     * that performs the 'needsUpdate' check.
     *
     * @type {boolean}
     * @readonly
     */
val needsUpdate: Boolean
/**
     * Returns the dynamic cache key which represents a key that is computed per draw command.
     *
     * @return {number} The cache key.
     */
fun getDynamicCacheKey(): Double
/**
     * Returns the render object's cache key.
     *
     * @return {number} The cache key.
     */
fun getCacheKey(): Double
/**
     * Frees internal resources.
     */
fun dispose(): Unit
}

/* export default RenderObject; */
external interface Temp84 {
var start: Double
var count: Double
}

external interface Temp85 {
operator fun get(key: String): Double?

operator fun set(key: String, value: Double?)
}

external interface Temp86 {
var start: Double
var count: Double
}

external interface Temp87 {
var vertexCount: Double
var firstVertex: Double
var instanceCount: Double
var firstInstance: Double
}

external interface Temp88 {
var vertexCount: Double
var firstVertex: Double
var instanceCount: Double
var firstInstance: Double
}