// Generated by Karakum - do not modify it manually!

@file:JsModule("threethree")

package three.src.renderers

// unhandled import: Camera from "../cameras/Camera.js"
// unhandled import: CullFace from "../constants.js"
// unhandled import: ShadowMapType from "../constants.js"
// unhandled import: TextureDataType from "../constants.js"
// unhandled import: ToneMapping from "../constants.js"
// unhandled import: WebGLCoordinateSystem from "../constants.js"
// unhandled import: TypedArray from "../core/BufferAttribute.js"
// unhandled import: BufferGeometry from "../core/BufferGeometry.js"
// unhandled import: Object3D from "../core/Object3D.js"
// unhandled import: Material from "../materials/Material.js"
// unhandled import: Box2 from "../math/Box2.js"
// unhandled import: Box3 from "../math/Box3.js"
// unhandled import: Color from "../math/Color.js"
// unhandled import: ColorRepresentation from "../math/Color.js"
// unhandled import: Plane from "../math/Plane.js"
// unhandled import: Vector2 from "../math/Vector2.js"
// unhandled import: Vector3 from "../math/Vector3.js"
// unhandled import: Vector4 from "../math/Vector4.js"
// unhandled import: Scene from "../scenes/Scene.js"
// unhandled import: OffscreenCanvas from "../textures/Texture.js"
// unhandled import: Texture from "../textures/Texture.js"
// unhandled import: WebGLCapabilities from "./webgl/WebGLCapabilities.js"
// unhandled import: WebGLCapabilitiesParameters from "./webgl/WebGLCapabilities.js"
// unhandled import: WebGLExtensions from "./webgl/WebGLExtensions.js"
// unhandled import: WebGLInfo from "./webgl/WebGLInfo.js"
// unhandled import: WebGLProgram from "./webgl/WebGLProgram.js"
// unhandled import: WebGLProperties from "./webgl/WebGLProperties.js"
// unhandled import: WebGLRenderLists from "./webgl/WebGLRenderLists.js"
// unhandled import: WebGLShadowMap from "./webgl/WebGLShadowMap.js"
// unhandled import: WebGLState from "./webgl/WebGLState.js"
// unhandled import: WebGLRenderTarget from "./WebGLRenderTarget.js"
// unhandled import: WebXRManager from "./webxr/WebXRManager.js"



















































external interface WebGLRendererParameters : WebGLCapabilitiesParameters {
/**
     * A Canvas where the renderer draws its output.
     */
var canvas: Any? /* HTMLCanvasElement | OffscreenCanvas | undefined */
/**
     * A WebGL Rendering Context.
     * (https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext)
     * Default is null
     */
var context: WebGLRenderingContext?
/**
     * default is false.
     */
var alpha: Boolean?
/**
     * default is true.
     */
var premultipliedAlpha: Boolean?
/**
     * default is false.
     */
var antialias: Boolean?
/**
     * default is false.
     */
var stencil: Boolean?
/**
     * default is false.
     */
var preserveDrawingBuffer: Boolean?
/**
     * Can be "high-performance", "low-power" or "default"
     */
var powerPreference: WebGLPowerPreference?
/**
     * default is true.
     */
var depth: Boolean?
/**
     * default is false.
     */
var failIfMajorPerformanceCaveat: Boolean?
/**
     * @default UnsignedByteType
     */
var outputBufferType: TextureDataType?
}

external interface WebGLDebug {
/**
     * Enables error checking and reporting when shader programs are being compiled.
     */
var checkShaderErrors: Boolean
/**
     * A callback function that can be used for custom error reporting. The callback receives the WebGL context, an
     * instance of WebGLProgram as well two instances of WebGLShader representing the vertex and fragment shader.
     * Assigning a custom function disables the default error reporting.
     * @default `null`
     */
var onShaderError: ((gl: WebGLRenderingContext, program: WebGLProgram, glVertexShader: WebGLShader, glFragmentShader: WebGLShader) -> Unit)?
}

external interface Effect {
fun setSize(width: Double, height: Double): Unit
fun render(renderer: WebGLRenderer, writeBuffer: WebGLRenderTarget, readBuffer: WebGLRenderTarget, deltaTime: Double, maskActive: Boolean): Unit
}

/**
 * The WebGL renderer displays your beautifully crafted scenes using WebGL, if your device supports it.
 * This renderer has way better performance than CanvasRenderer.
 *
 * see {@link https://github.com/mrdoob/three.js/blob/master/src/renderers/WebGLRenderer.js|src/renderers/WebGLRenderer.js}
 */
external class WebGLRenderer {
/**
     * parameters is an optional object with properties defining the renderer's behavior.
     * The constructor also accepts no parameters at all.
     * In all cases, it will assume sane defaults when parameters are missing.
     */
constructor (parameters: WebGLRendererParameters = definedExternally)
/**
     * A Canvas where the renderer draws its output.
     * This is automatically created by the renderer in the constructor (if not provided already); you just need to add it to your page.
     * @default document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' )
     */
var domElement: HTMLCanvasElement
/**
     * Defines whether the renderer should automatically clear its output before rendering.
     * @default true
     */
var autoClear: Boolean
/**
     * If autoClear is true, defines whether the renderer should clear the color buffer. Default is true.
     * @default true
     */
var autoClearColor: Boolean
/**
     * If autoClear is true, defines whether the renderer should clear the depth buffer. Default is true.
     * @default true
     */
var autoClearDepth: Boolean
/**
     * If autoClear is true, defines whether the renderer should clear the stencil buffer. Default is true.
     * @default true
     */
var autoClearStencil: Boolean
/**
     * Debug configurations.
     * @default { checkShaderErrors: true }
     */
var debug: WebGLDebug
/**
     * Defines whether the renderer should sort objects. Default is true.
     * @default true
     */
var sortObjects: Boolean
/**
     * @default []
     */
var clippingPlanes: js.array.ReadonlyArray<Plane>
/**
     * @default false
     */
var localClippingEnabled: Boolean
var extensions: WebGLExtensions
/**
     * Color space used for output to HTMLCanvasElement. Supported values are
     * {@link SRGBColorSpace} and {@link LinearSRGBColorSpace}.
     * @default THREE.SRGBColorSpace.
     */
var outputColorSpace: String
val coordinateSystem: Double /* 2000 */
/**
     * @default THREE.NoToneMapping
     */
var toneMapping: ToneMapping
/**
     * @default 1
     */
var toneMappingExposure: Double
/**
     * The normalized resolution scale for the transmission render target, measured in percentage of viewport
     * dimensions. Lowering this value can result in significant improvements to {@link MeshPhysicalMaterial}
     * transmission performance. Default is `1`.
     */
var transmissionResolutionScale: Double
var info: WebGLInfo
var shadowMap: WebGLShadowMap
var capabilities: WebGLCapabilities
var properties: WebGLProperties
var renderLists: WebGLRenderLists
var state: WebGLState
var xr: WebXRManager
/**
     * Return the WebGL context.
     */
fun getContext(): Any /* WebGLRenderingContext | WebGL2RenderingContext */
fun getContextAttributes(): Any?
fun forceContextLoss(): Unit
fun forceContextRestore(): Unit
/**
     * @deprecated Use {@link WebGLCapabilities#getMaxAnisotropy .capabilities.getMaxAnisotropy()} instead.
     */
fun getMaxAnisotropy(): Double
/**
     * @deprecated Use {@link WebGLCapabilities#precision .capabilities.precision} instead.
     */
fun getPrecision(): String
fun getPixelRatio(): Double
fun setPixelRatio(value: Double): Unit
fun getSize(target: Vector2): Vector2
/**
     * Resizes the output canvas to (width, height), and also sets the viewport to fit that size, starting in (0, 0).
     */
fun setSize(width: Double, height: Double, updateStyle: Boolean = definedExternally): Unit
fun getDrawingBufferSize(target: Vector2): Vector2
fun setDrawingBufferSize(width: Double, height: Double, pixelRatio: Double): Unit
fun setEffects(effects: js.array.ReadonlyArray<Effect>?): Unit
fun getCurrentViewport(target: Vector4): Vector4
/**
     * Copies the viewport into target.
     */
fun getViewport(target: Vector4): Vector4
/**
     * Sets the viewport to render from (x, y) to (x + width, y + height).
     * (x, y) is the lower-left corner of the region.
     */
fun setViewport(x: Vector4, y: Double = definedExternally, width: Double = definedExternally, height: Double = definedExternally): Unit

/**
     * Sets the viewport to render from (x, y) to (x + width, y + height).
     * (x, y) is the lower-left corner of the region.
     */
fun setViewport(x: Double, y: Double = definedExternally, width: Double = definedExternally, height: Double = definedExternally): Unit
/**
     * Copies the scissor area into target.
     */
fun getScissor(target: Vector4): Vector4
/**
     * Sets the scissor area from (x, y) to (x + width, y + height).
     */
fun setScissor(x: Vector4, y: Double = definedExternally, width: Double = definedExternally, height: Double = definedExternally): Unit

/**
     * Sets the scissor area from (x, y) to (x + width, y + height).
     */
fun setScissor(x: Double, y: Double = definedExternally, width: Double = definedExternally, height: Double = definedExternally): Unit
/**
     * Returns true if scissor test is enabled; returns false otherwise.
     */
fun getScissorTest(): Boolean
/**
     * Enable the scissor test. When this is enabled, only the pixels within the defined scissor area will be affected by further renderer actions.
     */
fun setScissorTest(enable: Boolean): Unit
/**
     * Sets the custom opaque sort function for the WebGLRenderLists. Pass null to use the default painterSortStable function.
     */
fun setOpaqueSort(method: ((a: Any?, b: Any?) -> Double)?): Unit
/**
     * Sets the custom transparent sort function for the WebGLRenderLists. Pass null to use the default reversePainterSortStable function.
     */
fun setTransparentSort(method: ((a: Any?, b: Any?) -> Double)?): Unit
/**
     * Returns a THREE.Color instance with the current clear color.
     */
fun getClearColor(target: Color): Color
/**
     * Sets the clear color, using color for the color and alpha for the opacity.
     */
fun setClearColor(color: ColorRepresentation, alpha: Double = definedExternally): Unit
/**
     * Returns a float with the current clear alpha. Ranges from 0 to 1.
     */
fun getClearAlpha(): Double
fun setClearAlpha(alpha: Double): Unit
/**
     * Tells the renderer to clear its color, depth or stencil drawing buffer(s).
     * Arguments default to true
     */
fun clear(color: Boolean = definedExternally, depth: Boolean = definedExternally, stencil: Boolean = definedExternally): Unit
fun clearColor(): Unit
fun clearDepth(): Unit
fun clearStencil(): Unit
fun clearTarget(renderTarget: WebGLRenderTarget, color: Boolean, depth: Boolean, stencil: Boolean): Unit
/**
     * @deprecated Use {@link WebGLState#reset .state.reset()} instead.
     */
fun resetGLState(): Unit
fun dispose(): Unit
fun renderBufferDirect(camera: Camera, scene: Scene, geometry: BufferGeometry, material: Material, `object`: Object3D, geometryGroup: Any?): Unit
/**
     * A build in function that can be used instead of requestAnimationFrame. For WebXR projects this function must be used.
     * @param callback The function will be called every available frame. If `null` is passed it will stop any already ongoing animation.
     */
fun setAnimationLoop(callback: XRFrameRequestCallback?): Unit
/**
     * @deprecated Use {@link WebGLRenderer#setAnimationLoop .setAnimationLoop()} instead.
     */
fun animate(callback: () -> Unit): Unit
/**
     * Compiles all materials in the scene with the camera. This is useful to precompile shaders before the first
     * rendering. If you want to add a 3D object to an existing scene, use the third optional parameter for applying the
     * target scene.
     * Note that the (target) scene's lighting should be configured before calling this method.
     */
var compile: (scene: Object3D, camera: Camera, targetScene: Scene? /* use undefined for default */) -> Set<Material>
/**
     * Asynchronous version of {@link compile}(). The method returns a Promise that resolves when the given scene can be
     * rendered without unnecessary stalling due to shader compilation.
     * This method makes use of the KHR_parallel_shader_compile WebGL extension.
     */
var compileAsync: (scene: Object3D, camera: Camera, targetScene: Scene? /* use undefined for default */) -> Promise<Object3D>
/**
     * Render a scene or an object using a camera.
     * The render is done to a previously specified {@link WebGLRenderTarget#renderTarget .renderTarget} set by calling
     * {@link WebGLRenderer#setRenderTarget .setRenderTarget} or to the canvas as usual.
     *
     * By default render buffers are cleared before rendering but you can prevent this by setting the property
     * {@link WebGLRenderer#autoClear autoClear} to false. If you want to prevent only certain buffers being cleared
     * you can set either the {@link WebGLRenderer#autoClearColor autoClearColor},
     * {@link WebGLRenderer#autoClearStencil autoClearStencil} or {@link WebGLRenderer#autoClearDepth autoClearDepth}
     * properties to false. To forcibly clear one ore more buffers call {@link WebGLRenderer#clear .clear}.
     */
fun render(scene: Object3D, camera: Camera): Unit
/**
     * Returns the current active cube face.
     */
fun getActiveCubeFace(): Double
/**
     * Returns the current active mipmap level.
     */
fun getActiveMipmapLevel(): Double
/**
     * Returns the current render target. If no render target is set, null is returned.
     */
fun getRenderTarget(): WebGLRenderTarget?
/**
     * @deprecated Use {@link WebGLRenderer#getRenderTarget .getRenderTarget()} instead.
     */
fun getCurrentRenderTarget(): WebGLRenderTarget?
/**
     * Sets the active render target.
     *
     * @param renderTarget The {@link WebGLRenderTarget renderTarget} that needs to be activated. When `null` is given, the canvas is set as the active render target instead.
     * @param activeCubeFace Specifies the active cube side (PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5) of {@link WebGLCubeRenderTarget}.
     * @param activeMipmapLevel Specifies the active mipmap level.
     */
fun setRenderTarget(renderTarget: WebGLRenderTarget?, activeCubeFace: Double = definedExternally, activeMipmapLevel: Double = definedExternally): Unit

/**
     * Sets the active render target.
     *
     * @param renderTarget The {@link WebGLRenderTarget renderTarget} that needs to be activated. When `null` is given, the canvas is set as the active render target instead.
     * @param activeCubeFace Specifies the active cube side (PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5) of {@link WebGLCubeRenderTarget}.
     * @param activeMipmapLevel Specifies the active mipmap level.
     */
fun setRenderTarget(renderTarget: WebGLRenderTarget<js.array.ReadonlyArray<Texture>>?, activeCubeFace: Double = definedExternally, activeMipmapLevel: Double = definedExternally): Unit
fun readRenderTargetPixels(renderTarget: WebGLRenderTarget, x: Double, y: Double, width: Double, height: Double, buffer: TypedArray, activeCubeFaceIndex: Double = definedExternally, textureIndex: Double = definedExternally): Unit

fun readRenderTargetPixels(renderTarget: WebGLRenderTarget<js.array.ReadonlyArray<Texture>>, x: Double, y: Double, width: Double, height: Double, buffer: TypedArray, activeCubeFaceIndex: Double = definedExternally, textureIndex: Double = definedExternally): Unit
fun readRenderTargetPixelsAsync(renderTarget: WebGLRenderTarget, x: Double, y: Double, width: Double, height: Double, buffer: TypedArray, activeCubeFaceIndex: Double = definedExternally, textureIndex: Double = definedExternally): Promise<TypedArray>

fun readRenderTargetPixelsAsync(renderTarget: WebGLRenderTarget<js.array.ReadonlyArray<Texture>>, x: Double, y: Double, width: Double, height: Double, buffer: TypedArray, activeCubeFaceIndex: Double = definedExternally, textureIndex: Double = definedExternally): Promise<TypedArray>
/**
     * Copies a region of the currently bound framebuffer into the selected mipmap level of the selected texture.
     * This region is defined by the size of the destination texture's mip level, offset by the input position.
     *
     * @param texture Specifies the destination texture.
     * @param position Specifies the pixel offset from which to copy out of the framebuffer.
     * @param level Specifies the destination mipmap level of the texture.
     */
fun copyFramebufferToTexture(texture: Texture, position: Vector2? = definedExternally, level: Double = definedExternally): Unit
/**
     * Copies the pixels of a texture in the bounds [srcRegion]{@link Box3} in the destination texture starting from the
     * given position. 2D Texture, 3D Textures, or a mix of the two can be used as source and destination texture
     * arguments for copying between layers of 3d textures
     *
     * The `depthTexture` and `texture` property of render targets are supported as well.
     *
     * When using render target textures as `srcTexture` and `dstTexture`, you must make sure both render targets are
     * initialized e.g. via {@link .initRenderTarget}().
     *
     * @param srcTexture Specifies the source texture.
     * @param dstTexture Specifies the destination texture.
     * @param srcRegion Specifies the bounds
     * @param dstPosition Specifies the pixel offset into the dstTexture where the copy will occur.
     * @param srcLevel Specifies the source mipmap level of the texture.
     * @param dstLevel Specifies the destination mipmap level of the texture.
     */
fun copyTextureToTexture(srcTexture: Texture, dstTexture: Texture): Unit

/**
     * Copies the pixels of a texture in the bounds [srcRegion]{@link Box3} in the destination texture starting from the
     * given position. 2D Texture, 3D Textures, or a mix of the two can be used as source and destination texture
     * arguments for copying between layers of 3d textures
     *
     * The `depthTexture` and `texture` property of render targets are supported as well.
     *
     * When using render target textures as `srcTexture` and `dstTexture`, you must make sure both render targets are
     * initialized e.g. via {@link .initRenderTarget}().
     *
     * @param srcTexture Specifies the source texture.
     * @param dstTexture Specifies the destination texture.
     * @param srcRegion Specifies the bounds
     * @param dstPosition Specifies the pixel offset into the dstTexture where the copy will occur.
     * @param srcLevel Specifies the source mipmap level of the texture.
     * @param dstLevel Specifies the destination mipmap level of the texture.
     */
fun copyTextureToTexture(srcTexture: Texture, dstTexture: Texture, srcRegion: Box2? = definedExternally, dstPosition: Vector2? = definedExternally, srcLevel: Double = definedExternally, dstLevel: Double = definedExternally): Unit

/**
     * Copies the pixels of a texture in the bounds [srcRegion]{@link Box3} in the destination texture starting from the
     * given position. 2D Texture, 3D Textures, or a mix of the two can be used as source and destination texture
     * arguments for copying between layers of 3d textures
     *
     * The `depthTexture` and `texture` property of render targets are supported as well.
     *
     * When using render target textures as `srcTexture` and `dstTexture`, you must make sure both render targets are
     * initialized e.g. via {@link .initRenderTarget}().
     *
     * @param srcTexture Specifies the source texture.
     * @param dstTexture Specifies the destination texture.
     * @param srcRegion Specifies the bounds
     * @param dstPosition Specifies the pixel offset into the dstTexture where the copy will occur.
     * @param srcLevel Specifies the source mipmap level of the texture.
     * @param dstLevel Specifies the destination mipmap level of the texture.
     */
fun copyTextureToTexture(srcTexture: Texture, dstTexture: Texture, srcRegion: Box2? = definedExternally, dstPosition: Vector3? = definedExternally, srcLevel: Double = definedExternally, dstLevel: Double = definedExternally): Unit

/**
     * Copies the pixels of a texture in the bounds [srcRegion]{@link Box3} in the destination texture starting from the
     * given position. 2D Texture, 3D Textures, or a mix of the two can be used as source and destination texture
     * arguments for copying between layers of 3d textures
     *
     * The `depthTexture` and `texture` property of render targets are supported as well.
     *
     * When using render target textures as `srcTexture` and `dstTexture`, you must make sure both render targets are
     * initialized e.g. via {@link .initRenderTarget}().
     *
     * @param srcTexture Specifies the source texture.
     * @param dstTexture Specifies the destination texture.
     * @param srcRegion Specifies the bounds
     * @param dstPosition Specifies the pixel offset into the dstTexture where the copy will occur.
     * @param srcLevel Specifies the source mipmap level of the texture.
     * @param dstLevel Specifies the destination mipmap level of the texture.
     */
fun copyTextureToTexture(srcTexture: Texture, dstTexture: Texture, srcRegion: Box3? = definedExternally, dstPosition: Vector2? = definedExternally, srcLevel: Double = definedExternally, dstLevel: Double = definedExternally): Unit

/**
     * Copies the pixels of a texture in the bounds [srcRegion]{@link Box3} in the destination texture starting from the
     * given position. 2D Texture, 3D Textures, or a mix of the two can be used as source and destination texture
     * arguments for copying between layers of 3d textures
     *
     * The `depthTexture` and `texture` property of render targets are supported as well.
     *
     * When using render target textures as `srcTexture` and `dstTexture`, you must make sure both render targets are
     * initialized e.g. via {@link .initRenderTarget}().
     *
     * @param srcTexture Specifies the source texture.
     * @param dstTexture Specifies the destination texture.
     * @param srcRegion Specifies the bounds
     * @param dstPosition Specifies the pixel offset into the dstTexture where the copy will occur.
     * @param srcLevel Specifies the source mipmap level of the texture.
     * @param dstLevel Specifies the destination mipmap level of the texture.
     */
fun copyTextureToTexture(srcTexture: Texture, dstTexture: Texture, srcRegion: Box3? = definedExternally, dstPosition: Vector3? = definedExternally, srcLevel: Double = definedExternally, dstLevel: Double = definedExternally): Unit
/**
     * Initializes the given WebGLRenderTarget memory. Useful for initializing a render target so data can be copied
     * into it using {@link WebGLRenderer.copyTextureToTexture} before it has been rendered to.
     * @param target
     */
fun initRenderTarget(target: WebGLRenderTarget): Unit
/**
     * Initializes the given texture. Can be used to preload a texture rather than waiting until first render (which can cause noticeable lags due to decode and GPU upload overhead).
     *
     * @param texture The texture to Initialize.
     */
fun initTexture(texture: Texture): Unit
/**
     * Can be used to reset the internal WebGL state.
     */
fun resetState(): Unit
/**
     * @deprecated Use {@link WebGLRenderer#xr .xr} instead.
     */
var vr: Boolean
/**
     * @deprecated Use {@link WebGLShadowMap#enabled .shadowMap.enabled} instead.
     */
var shadowMapEnabled: Boolean
/**
     * @deprecated Use {@link WebGLShadowMap#type .shadowMap.type} instead.
     */
var shadowMapType: ShadowMapType
/**
     * @deprecated Use {@link WebGLShadowMap#cullFace .shadowMap.cullFace} instead.
     */
var shadowMapCullFace: CullFace
/**
     * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'OES_texture_float' )} instead.
     */
fun supportsFloatTextures(): Any?
/**
     * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'OES_texture_half_float' )} instead.
     */
fun supportsHalfFloatTextures(): Any?
/**
     * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'OES_standard_derivatives' )} instead.
     */
fun supportsStandardDerivatives(): Any?
/**
     * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'WEBGL_compressed_texture_s3tc' )} instead.
     */
fun supportsCompressedTextureS3TC(): Any?
/**
     * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'WEBGL_compressed_texture_pvrtc' )} instead.
     */
fun supportsCompressedTexturePVRTC(): Any?
/**
     * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'EXT_blend_minmax' )} instead.
     */
fun supportsBlendMinMax(): Any?
/**
     * @deprecated Use {@link WebGLCapabilities#vertexTextures .capabilities.vertexTextures} instead.
     */
fun supportsVertexTextures(): Any?
/**
     * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'ANGLE_instanced_arrays' )} instead.
     */
fun supportsInstancedArrays(): Any?
/**
     * @deprecated Use {@link WebGLRenderer#setScissorTest .setScissorTest()} instead.
     */
fun enableScissorTest(boolean: Any?): Any?
}
