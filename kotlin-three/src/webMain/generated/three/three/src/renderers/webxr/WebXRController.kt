// Generated by Karakum - do not modify it manually!

@file:JsModule("threethree")

package three.src.renderers.webxr

// unhandled import: Object3DEventMap from "../../core/Object3D.js"
// unhandled import: Vector3 from "../../math/Vector3.js"
// unhandled import: Group from "../../objects/Group.js"







typealias XRControllerEventType = Any /* XRSessionEventType | XRInputSourceEventType | "disconnected" | "connected" */

external class XRJointSpace : Group {
val jointRadius: Double?
}

typealias XRHandJoints = Record<XRHandJoint, XRJointSpace>

external interface XRHandInputState {
var pinching: Boolean
}

external interface WebXRSpaceEventMap : Object3DEventMap {
var select: WebXRSpaceEventMapSelect
var selectstart: WebXRSpaceEventMapSelectstart
var selectend: WebXRSpaceEventMapSelectend
var squeeze: WebXRSpaceEventMapSqueeze
var squeezestart: WebXRSpaceEventMapSqueezestart
var squeezeend: WebXRSpaceEventMapSqueezeend
var connected: WebXRSpaceEventMapConnected
var disconnected: WebXRSpaceEventMapDisconnected
var pinchend: WebXRSpaceEventMapPinchend// This Event break the THREE.EventDispatcher contract, replacing the target to the wrong instance.

var pinchstart: WebXRSpaceEventMapPinchstart// This Event break the THREE.EventDispatcher contract, replacing the target to the wrong instance.

var move: Any
}

external class XRHandSpace : Group<WebXRSpaceEventMap> {
val joints: Partial<XRHandJoints>
val inputState: XRHandInputState
}

external class XRTargetRaySpace : Group<WebXRSpaceEventMap> {
var hasLinearVelocity: Boolean
val linearVelocity: Vector3
var hasAngularVelocity: Boolean
val angularVelocity: Vector3
}

external class XRGripSpace : Group<WebXRSpaceEventMap> {
var hasLinearVelocity: Boolean
val linearVelocity: Vector3
var hasAngularVelocity: Boolean
val angularVelocity: Vector3
}

external class WebXRController {
constructor ()
fun getHandSpace(): XRHandSpace
fun getTargetRaySpace(): XRTargetRaySpace
fun getGripSpace(): XRGripSpace
fun dispatchEvent(event: WebXRControllerDispatchEventEvent): Unit /* this */
fun connect(inputSource: XRInputSource): Unit /* this */
fun disconnect(inputSource: XRInputSource): Unit /* this */
fun update(inputSource: XRInputSource, frame: XRFrame, referenceSpace: XRReferenceSpace): Unit /* this */
}
external interface WebXRSpaceEventMapSelect {
var data: XRInputSource
}

external interface WebXRSpaceEventMapSelectstart {
var data: XRInputSource
}

external interface WebXRSpaceEventMapSelectend {
var data: XRInputSource
}

external interface WebXRSpaceEventMapSqueeze {
var data: XRInputSource
}

external interface WebXRSpaceEventMapSqueezestart {
var data: XRInputSource
}

external interface WebXRSpaceEventMapSqueezeend {
var data: XRInputSource
}

external interface WebXRSpaceEventMapConnected {
var data: XRInputSource
}

external interface WebXRSpaceEventMapDisconnected {
var data: XRInputSource
}

external interface WebXRSpaceEventMapPinchend {
var handedness: XRHandedness
var target: WebXRController
}

external interface WebXRSpaceEventMapPinchstart {
var handedness: XRHandedness
var target: WebXRController
}

external interface WebXRControllerDispatchEventEvent {
var type: XRControllerEventType
var data: XRInputSource?
}