// Generated by Karakum - do not modify it manually!

@file:JsModule("threethree")

package three.src.renderers.common

// unhandled import: RenderTarget from "../../core/RenderTarget.js"
// unhandled import: Vector3 from "../../math/Vector3.js"
// unhandled import: DepthTexture from "../../textures/DepthTexture.js"
// unhandled import: Texture from "../../textures/Texture.js"
// unhandled import: default as Backend from "./Backend.js"
// unhandled import: default as DataMap from "./DataMap.js"
// unhandled import: default as Info from "./Info.js"
// unhandled import: default as Renderer from "./Renderer.js"

















external interface SizeVector3Uninitialized : Vector3 {
var width: Double?
var height: Double?
var depth: Double?
}

external interface SizeVector3 : Vector3 {
var width: Double
var height: Double
var depth: Double
}

external interface RenderTargetData {
var depthTextureMips: (RenderTargetDataDepthTextureMips)?
var width: Double?
var height: Double?
var textures: js.array.ReadonlyArray<Texture>?
var depthTexture: DepthTexture?
var depth: Boolean?
var stencil: Boolean?
var renderTarget: RenderTarget?
var sampleCount: Double?
var initialized: Boolean?
}

external interface TextureData {
var initialized: Boolean?
var version: Double?
var isDefaultTexture: Boolean?
var generation: Double?
}

external interface TextureOptions {
var width: Double?
var height: Double?
var depth: Double?
var needsMipmaps: Boolean?
var levels: Double?
}

/**
 * This module manages the textures of the renderer.
 *
 * @private
 * @augments DataMap
 */
external class Textures : DataMap<Temp100> {
/**
     * Constructs a new texture management component.
     *
     * @param {Renderer} renderer - The renderer.
     * @param {Backend} backend - The renderer's backend.
     * @param {Info} info - Renderer component for managing metrics and monitoring data.
     */
constructor (renderer: Renderer, backend: Backend, info: Info)
var renderer: Renderer
var backend: Backend
var info: Info
/**
     * Updates the given render target. Based on the given render target configuration,
     * it updates the texture states representing the attachments of the framebuffer.
     *
     * @param {RenderTarget} renderTarget - The render target to update.
     * @param {number} [activeMipmapLevel=0] - The active mipmap level.
     */
fun updateRenderTarget(renderTarget: RenderTarget, activeMipmapLevel: Double = definedExternally): Unit
/**
     * Updates the given texture. Depending on the texture state, this method
     * triggers the upload of texture data to the GPU memory. If the texture data are
     * not yet ready for the upload, it uses default texture data for as a placeholder.
     *
     * @param {Texture} texture - The texture to update.
     * @param {Object} [options={}] - The options.
     */
fun updateTexture(texture: Texture, options: TextureOptions = definedExternally): Unit
/**
     * Updates the sampler for the given texture. This method has no effect
     * for the WebGL backend since it has no concept of samplers. Texture
     * parameters are configured with the `texParameter()` command for each
     * texture.
     *
     * In WebGPU, samplers are objects like textures and it's possible to share
     * them when the texture parameters match.
     *
     * @param {Texture} texture - The texture to update the sampler for.
     * @return {string} The current sampler key.
     */
fun updateSampler(texture: Texture): Unit
/**
     * Computes the size of the given texture and writes the result
     * into the target vector. This vector is also returned by the
     * method.
     *
     * If no texture data are available for the compute yet, the method
     * returns default size values.
     *
     * @param {Texture} texture - The texture to compute the size for.
     * @param {Vector3} target - The target vector.
     * @return {Vector3} The target vector.
     */
fun getSize(texture: Texture, target: SizeVector3Uninitialized = definedExternally): SizeVector3
/**
     * Computes the number of mipmap levels for the given texture.
     *
     * @param {Texture} texture - The texture.
     * @param {number} width - The texture's width.
     * @param {number} height - The texture's height.
     * @return {number} The number of mipmap levels.
     */
fun getMipLevels(texture: Texture, width: Double, height: Double): Double
/**
     * Returns `true` if the given texture makes use of mipmapping.
     *
     * @param {Texture} texture - The texture.
     * @return {boolean} Whether mipmaps are required or not.
     */
fun needsMipmaps(texture: Texture): Boolean
/**
     * Frees internal resources when the given render target isn't
     * required anymore.
     *
     * @param {RenderTarget} renderTarget - The render target to destroy.
     */
fun _destroyRenderTarget(renderTarget: RenderTarget): Unit
/**
     * Frees internal resource when the given texture isn't
     * required anymore.
     *
     * @param {Texture} texture - The texture to destroy.
     */
fun _destroyTexture(texture: Texture): Unit
}

/* export default Textures; */
external interface RenderTargetDataDepthTextureMips {
operator fun get(key: Double): DepthTexture?

operator fun set(key: Double, value: DepthTexture?)
}

external interface Temp101 {
var key: RenderTarget
var value: RenderTargetData
}

external interface Temp102 {
var key: Texture
var value: TextureData
}

external interface Temp100 {
var renderTarget: Temp101
var texture: Temp102
}