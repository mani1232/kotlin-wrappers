// Generated by Karakum - do not modify it manually!

@file:JsModule("threethree")

package three.src.nodes.core

/**
 * Possible shader stages.
 *
 * @property {string} VERTEX The vertex shader stage.
 * @property {string} FRAGMENT The fragment shader stage.
 */
external val NodeShaderStage: NodeShaderStage

/**
 * Update types of a node.
 *
 * @property {string} NONE The update method is not executed.
 * @property {string} FRAME The update method is executed per frame.
 * @property {string} RENDER The update method is executed per render. A frame might be produced by multiple render calls so this value allows more detailed updates than FRAME.
 * @property {string} OBJECT The update method is executed per {@link Object3D} that uses the node for rendering.
 */
external val NodeUpdateType: NodeUpdateType

/**
 * Data types of a node.
 *
 * @property {string} BOOLEAN Boolean type.
 * @property {string} INTEGER Integer type.
 * @property {string} FLOAT Float type.
 * @property {string} VECTOR2 Two-dimensional vector type.
 * @property {string} VECTOR3 Three-dimensional vector type.
 * @property {string} VECTOR4 Four-dimensional vector type.
 * @property {string} MATRIX2 2x2 matrix type.
 * @property {string} MATRIX3 3x3 matrix type.
 * @property {string} MATRIX4 4x4 matrix type.
 */
external val NodeType: NodeType

/**
 * Access types of a node. These are relevant for compute and storage usage.
 *
 * @property {string} READ_ONLY Read-only access
 * @property {string} WRITE_ONLY Write-only access.
 * @property {string} READ_WRITE Read and write access.
 */
external val NodeAccess: NodeAccess

sealed external interface NodeShaderStage {
companion object {
@seskar.js.JsValue("vertex")
val vertex: NodeShaderStage
@seskar.js.JsValue("fragment")
val fragment: NodeShaderStage
@seskar.js.JsValue("compute")
val compute: NodeShaderStage
}
}

sealed external interface NodeUpdateType {
companion object {
@seskar.js.JsValue("none")
val none: NodeUpdateType
@seskar.js.JsValue("frame")
val frame: NodeUpdateType
@seskar.js.JsValue("render")
val render: NodeUpdateType
@seskar.js.JsValue("object")
val `object`: NodeUpdateType
}
}

sealed external interface NodeAccess {
companion object {
@seskar.js.JsValue("readOnly")
val readOnly: NodeAccess
@seskar.js.JsValue("writeOnly")
val writeOnly: NodeAccess
@seskar.js.JsValue("readWrite")
val readWrite: NodeAccess
}
}

external val defaultShaderStages: js.array.ReadonlyArray<NodeShaderStage>

external val defaultBuildStages: js.array.ReadonlyArray<String>

external val shaderStages: js.array.ReadonlyArray<NodeShaderStage>

external val vectorComponents: js.array.ReadonlyArray<String>
external interface NodeShaderStage {
val VERTEX: String /* "vertex" */
val FRAGMENT: String /* "fragment" */
}

external interface NodeUpdateType {
val NONE: String /* "none" */
val FRAME: String /* "frame" */
val RENDER: String /* "render" */
val OBJECT: String /* "object" */
}

external interface NodeType {
val BOOLEAN: String /* "bool" */
val INTEGER: String /* "int" */
val FLOAT: String /* "float" */
val VECTOR2: String /* "vec2" */
val VECTOR3: String /* "vec3" */
val VECTOR4: String /* "vec4" */
val MATRIX2: String /* "mat2" */
val MATRIX3: String /* "mat3" */
val MATRIX4: String /* "mat4" */
}

external interface NodeAccess {
val READ_ONLY: String /* "readOnly" */
val WRITE_ONLY: String /* "writeOnly" */
val READ_WRITE: String /* "readWrite" */
}