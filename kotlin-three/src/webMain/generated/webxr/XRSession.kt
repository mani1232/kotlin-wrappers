// Generated by Karakum - do not modify it manually!

@file:JsModule("webxrwebxr")

package webxr

/**
 * Any interaction with XR hardware is done via an XRSession object, which can only be
 * retrieved by calling requestSession() on the XRSystem object. Once a session has been
 * successfully acquired, it can be used to poll the viewer pose, query information about
 * the user's environment, and present imagery to the user.
 *
 * ref: https://immersive-web.github.io/webxr/#xrsession-interface
 */


external class XRSession : XRSession, EventTarget {
/**
     * Returns a list of this session's XRInputSources, each representing an input device
     * used to control the camera and/or scene.
     */
val inputSources: XRInputSourceArray
/**
     * object which contains options affecting how the imagery is rendered.
     * This includes things such as the near and far clipping planes
     */
val renderState: XRRenderState
val environmentBlendMode: XREnvironmentBlendMode
val visibilityState: XRVisibilityState
val frameRate: Double?
val supportedFrameRates: Float32Array?
val enabledFeatures: js.array.ReadonlyArray<String>?
val isSystemKeyboardSupported: Boolean
val interactionMode: XRInteractionMode?
/**
     * Removes a callback from the animation frame painting callback from
     * XRSession's set of animation frame rendering callbacks, given the
     * identifying handle returned by a previous call to requestAnimationFrame().
     */
fun cancelAnimationFrame(id: Double): Unit
/**
     * Ends the WebXR session. Returns a promise which resolves when the
     * session has been shut down.
     */
fun end(): Promise<js.core.Void>
/**
     * Schedules the specified method to be called the next time the user agent
     * is working on rendering an animation frame for the WebXR device. Returns an
     * integer value which can be used to identify the request for the purposes of
     * canceling the callback using cancelAnimationFrame(). This method is comparable
     * to the Window.requestAnimationFrame() method.
     */
fun requestAnimationFrame(callback: XRFrameRequestCallback): Double
/**
     * Requests that a new XRReferenceSpace of the specified type be created.
     * Returns a promise which resolves with the XRReferenceSpace or
     * XRBoundedReferenceSpace which was requested, or throws a NotSupportedError if
     * the requested space type isn't supported by the device.
     */
fun requestReferenceSpace(type: XRReferenceSpaceType): Promise<Any /* XRReferenceSpace | XRBoundedReferenceSpace */>
fun updateRenderState(renderStateInit: XRRenderStateInit = definedExternally): Promise<js.core.Void>
fun updateTargetFrameRate(rate: Double): Promise<js.core.Void>
var onend: XRSessionEventHandler
var oninputsourceschange: XRInputSourcesChangeEventHandler
var onselect: XRInputSourceEventHandler
var onselectstart: XRInputSourceEventHandler
var onselectend: XRInputSourceEventHandler
var onsqueeze: XRInputSourceEventHandler
var onsqueezestart: XRInputSourceEventHandler
var onsqueezeend: XRInputSourceEventHandler
var onvisibilitychange: XRSessionEventHandler
var onframeratechange: XRSessionEventHandler
fun <K : /* keyof XRSessionEventMap */> addEventListener(type: K, listener: (/* this: XRSession, */ ev: Any?) -> Any?): Unit

fun <K : /* keyof XRSessionEventMap */> addEventListener(type: K, listener: (/* this: XRSession, */ ev: Any?) -> Any?, options: Boolean = definedExternally): Unit

fun <K : /* keyof XRSessionEventMap */> addEventListener(type: K, listener: (/* this: XRSession, */ ev: Any?) -> Any?, options: AddEventListenerOptions = definedExternally): Unit
fun addEventListener(type: String, listener: EventListenerOrEventListenerObject): Unit

fun addEventListener(type: String, listener: EventListenerOrEventListenerObject, options: Boolean = definedExternally): Unit

fun addEventListener(type: String, listener: EventListenerOrEventListenerObject, options: AddEventListenerOptions = definedExternally): Unit
fun <K : /* keyof XRSessionEventMap */> removeEventListener(type: K, listener: (/* this: XRSession, */ ev: Any?) -> Any?): Unit

fun <K : /* keyof XRSessionEventMap */> removeEventListener(type: K, listener: (/* this: XRSession, */ ev: Any?) -> Any?, options: Boolean = definedExternally): Unit

fun <K : /* keyof XRSessionEventMap */> removeEventListener(type: K, listener: (/* this: XRSession, */ ev: Any?) -> Any?, options: EventListenerOptions = definedExternally): Unit
fun removeEventListener(type: String, listener: EventListenerOrEventListenerObject): Unit

fun removeEventListener(type: String, listener: EventListenerOrEventListenerObject, options: Boolean = definedExternally): Unit

fun removeEventListener(type: String, listener: EventListenerOrEventListenerObject, options: EventListenerOptions = definedExternally): Unit
/**
     * A list of the known persistent anchors
     */
val persistentAnchors: js.array.ReadonlyArray<String>?
/**
     * Restores a persistent anchor with the given UUID.
     *
     * If the sessions map of persistent anchors does not contain the given UUID or if the
     * session has ended, the promise will be rejected with a InvalidStateError.
     *
     * @see https://immersive-web.github.io/anchors/#dom-xrsession-restorepersistentanchor
     */
var restorePersistentAnchor: ((uuid: String) -> Promise<XRAnchor>)?
/**
     * Deletes the persistent anchor with the given UUID. Also deletes the anchor.
     *
     * If the sessions map of persistent anchors does not contain the given UUID the
     * promise will be rejected with a InvalidStateError.
     *
     * @see https://immersive-web.github.io/anchors/#dom-xrsession-deletepersistentanchor
     */
var deletePersistentAnchor: ((uuid: String) -> Promise<js.core.Void>)?
var requestHitTestSource: ((options: XRHitTestOptionsInit) -> Promise<XRHitTestSource>?)?
var requestHitTestSourceForTransientInput: ((options: XRTransientInputHitTestOptionsInit) -> Promise<XRTransientInputHitTestSource>?)?
// Legacy
var requestHitTest: ((ray: XRRay, referenceSpace: XRReferenceSpace) -> Promise<js.array.ReadonlyArray<XRHitResult>>?)?
/**
     * XRSession is extended to contain the initiateRoomCapture method which,
     * if supported, will ask the XR Compositor to capture the current room layout.
     * It is up to the XRCompositor if this will replace or augment the set of tracked planes.
     * The user agent MAY also ignore this call, for instance if it doesnâ€™t support a manual room
     * capture more or if it determines that the room is already set up.
     * The initiateRoomCapture method MUST only be able to be called once per XRSession.
     *
     * @see https://immersive-web.github.io/real-world-geometry/plane-detection.html#plane-set
     */
val initiateRoomCapture: (() -> Promise<Nothing?>)?
val domOverlayState: XRDOMOverlayState?
val depthUsage: XRDepthUsage?
val depthDataFormat: XRDepthDataFormat?
val depthType: XRDepthType?
val depthActive: Boolean?
val pauseDepthSensing: (() -> Unit)?
val resumeDepthSensing: (() -> Unit)?
}
